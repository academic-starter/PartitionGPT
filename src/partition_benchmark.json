{
    "AuctionInstance": [
        {
            "target_contract_name": "AuctionInstance",
            "target_func_name": "RaiseBidding",
            "original": " contract AuctionInstance{\n address[] BiddingAddress;\nbool auction_state = true;\nOrderDetail public orderdetail;\nbool auction_retracted = false;\naddress _owner;\nmapping(address => Bidding) Biddinglist;\nstruct OrderDetail {\n        //      OrderDetail                                      \n        string OrderInfo; // OrderInfo                                   \n        string Coal_Category; // Coal_Category      \n        uint256 Reserve_PriceInUnit; // Reserve_PriceInUnit      \n        uint256 Quantity; // Quantity       \n        uint256 Minimalsplit; // Minimalsplit      /                                            \n        uint256 Launch_Time; // Launch_Time        \n        uint256 Deadline; // Deadline        \n    }\nstruct Bidding {\n        //      Bidding             \n        uint32 PriceInUnit; // PriceInUnit      \n        uint32 Quantity; // Quantity   /     \n        uint256 Bidding_Time; // Bidding_Time      \n        bool Liveness; // Liveness                                    \n    }\nstruct ExtractedFinal {\n        //     ExtractedFinal                                     \n        uint8 Bidder_Cindex; // Bidder_Cindex                     \n        uint32 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\nstruct TopBidder4seller {\n        //      TopBidder4seller                      \n        uint8 Bidder_index; // Bidder_index                     \n        uint8 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\n\n\nfunction RaiseBidding(\n        uint32 _priceinunit,\n        uint32 _quantity\n    ) external AuctionOn OutsourseImmutability forbidOwner normalfunctioned {\n        uint32 epriceinunit = _priceinunit; \n        uint32 equantity = _quantity; \n        uint32 ereservepriceinunit = uint32(orderdetail.Reserve_PriceInUnit); \n        uint32 equantityintotal = uint32(orderdetail.Quantity); \n        uint32 eminimalsplit = uint32(orderdetail.Minimalsplit); \n        bool condition4price = epriceinunit >= ereservepriceinunit; \n        bool condition4enoughquantity = equantity <= equantityintotal; \n        bool condition4splitquantity = eminimalsplit <= equantity;\n        bool condition4quantity = condition4enoughquantity && condition4splitquantity;\n\n        require(\n            condition4price,\n            \"The price for the current bidding is invalid, your state of bidding remains unchanged.\"\n        );\n        require( \n            condition4quantity,\n            \"The quantity for the current bidding is invalid, your state of bidding remains unchanged.\"\n        );\n        if (!Biddinglist[msg.sender].Liveness) {\n            BiddingAddress.push(msg.sender);\n        }\n        Biddinglist[msg.sender] = Bidding(epriceinunit, equantity, block.timestamp, true);\n    }\n\nmodifier OutsourseImmutability() {\n        require(msg.sender == tx.origin, \"You are not an external account in Ethereum.\");\n        _;\n    }\n\nmodifier forbidOwner() {\n        require(tx.origin != _owner, \"The creator himself should not interfere in the procedure of bidding.\");\n        _;\n    }\n\nmodifier AuctionOn() {\n        if (block.timestamp > orderdetail.Deadline) {\n            auction_state = false;\n            return;\n        } else {\n            _;\n        }\n    }\n\nmodifier normalfunctioned() {\n        require(!auction_retracted, \"The auction has been retracted.\");\n        _;\n    }}",
            "partition": " contract AuctionInstance{\n bool auction_retracted = false;\naddress _owner;\nmapping(address => Bidding) Biddinglist;\naddress[] BiddingAddress;\nbool auction_state = true;\nOrderDetail public orderdetail;\nstruct OrderDetail {\n        //      OrderDetail                                      \n        string OrderInfo; // OrderInfo                                   \n        string Coal_Category; // Coal_Category      \n        uint256 Reserve_PriceInUnit; // Reserve_PriceInUnit      \n        uint256 Quantity; // Quantity       \n        uint256 Minimalsplit; // Minimalsplit      /                                            \n        uint256 Launch_Time; // Launch_Time        \n        uint256 Deadline; // Deadline        \n    }\nstruct Bidding {\n        //      Bidding             \n        uint32 PriceInUnit; // PriceInUnit      \n        uint32 Quantity; // Quantity   /     \n        uint256 Bidding_Time; // Bidding_Time      \n        bool Liveness; // Liveness                                    \n    }\nstruct ExtractedFinal {\n        //     ExtractedFinal                                     \n        uint8 Bidder_Cindex; // Bidder_Cindex                     \n        uint32 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\nstruct TopBidder4seller {\n        //      TopBidder4seller                      \n        uint8 Bidder_index; // Bidder_index                     \n        uint8 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\n\n\nfunction RaiseBidding(\n        uint32 _priceinunit,\n        uint32 _quantity\n    ) external AuctionOn OutsourseImmutability forbidOwner normalfunctioned {\n        RaiseBidding_priv(_priceinunit, _quantity);\n    }\n\nmodifier AuctionOn() {\n        if (block.timestamp > orderdetail.Deadline) {\n            auction_state = false;\n            return;\n        } else {\n            _;\n        }\n    }\n\nmodifier normalfunctioned() {\n        require(!auction_retracted, \"The auction has been retracted.\");\n        _;\n    }\n\nmodifier OutsourseImmutability() {\n        require(msg.sender == tx.origin, \"You are not an external account in Ethereum.\");\n        _;\n    }\n\nfunction RaiseBidding_priv(\n        uint32 _priceinunit,\n        uint32 _quantity\n    ) internal {\n        uint32 epriceinunit = _priceinunit; \n        uint32 equantity = _quantity; \n        uint32 ereservepriceinunit = uint32(orderdetail.Reserve_PriceInUnit); \n        uint32 equantityintotal = uint32(orderdetail.Quantity); \n        uint32 eminimalsplit = uint32(orderdetail.Minimalsplit); \n        bool condition4price = epriceinunit >= ereservepriceinunit; \n        bool condition4enoughquantity = equantity <= equantityintotal; \n        bool condition4splitquantity = eminimalsplit <= equantity;\n        bool condition4quantity = condition4enoughquantity && condition4splitquantity;\n\n        require(\n            condition4price,\n            \"The price for the current bidding is invalid, your state of bidding remains unchanged.\"\n        );\n        require( \n            condition4quantity,\n            \"The quantity for the current bidding is invalid, your state of bidding remains unchanged.\"\n        );\n        if (!Biddinglist[msg.sender].Liveness) {\n            BiddingAddress.push(msg.sender);\n        }\n        Biddinglist[msg.sender] = Bidding(epriceinunit, equantity, block.timestamp, true);\n    }\n\nmodifier forbidOwner() {\n        require(tx.origin != _owner, \"The creator himself should not interfere in the procedure of bidding.\");\n        _;\n    }}"
        },
        {
            "target_contract_name": "AuctionInstance",
            "target_func_name": "RetractBidding",
            "original": " contract AuctionInstance{\n bool auction_state = true;\nOrderDetail public orderdetail;\nbool auction_retracted = false;\naddress _owner;\nmapping(address => Bidding) Biddinglist;\nstruct OrderDetail {\n        //      OrderDetail                                      \n        string OrderInfo; // OrderInfo                                   \n        string Coal_Category; // Coal_Category      \n        uint256 Reserve_PriceInUnit; // Reserve_PriceInUnit      \n        uint256 Quantity; // Quantity       \n        uint256 Minimalsplit; // Minimalsplit      /                                            \n        uint256 Launch_Time; // Launch_Time        \n        uint256 Deadline; // Deadline        \n    }\nstruct Bidding {\n        //      Bidding             \n        uint32 PriceInUnit; // PriceInUnit      \n        uint32 Quantity; // Quantity   /     \n        uint256 Bidding_Time; // Bidding_Time      \n        bool Liveness; // Liveness                                    \n    }\nstruct ExtractedFinal {\n        //     ExtractedFinal                                     \n        uint8 Bidder_Cindex; // Bidder_Cindex                     \n        uint32 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\nstruct TopBidder4seller {\n        //      TopBidder4seller                      \n        uint8 Bidder_index; // Bidder_index                     \n        uint8 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\n\n\nfunction RetractBidding() external AuctionOn OutsourseImmutability forbidOwner normalfunctioned {\n        Biddinglist[msg.sender].Liveness = false;\n        Biddinglist[msg.sender].Bidding_Time = 0;\n    }\n\nmodifier forbidOwner() {\n        require(tx.origin != _owner, \"The creator himself should not interfere in the procedure of bidding.\");\n        _;\n    }\n\nmodifier OutsourseImmutability() {\n        require(msg.sender == tx.origin, \"You are not an external account in Ethereum.\");\n        _;\n    }\n\nmodifier AuctionOn() {\n        if (block.timestamp > orderdetail.Deadline) {\n            auction_state = false;\n            return;\n        } else {\n            _;\n        }\n    }\n\nmodifier normalfunctioned() {\n        require(!auction_retracted, \"The auction has been retracted.\");\n        _;\n    }}",
            "partition": " contract AuctionInstance{\n bool auction_retracted = false;\naddress _owner;\nmapping(address => Bidding) Biddinglist;\nbool auction_state = true;\nOrderDetail public orderdetail;\nstruct OrderDetail {\n        //      OrderDetail                                      \n        string OrderInfo; // OrderInfo                                   \n        string Coal_Category; // Coal_Category      \n        uint256 Reserve_PriceInUnit; // Reserve_PriceInUnit      \n        uint256 Quantity; // Quantity       \n        uint256 Minimalsplit; // Minimalsplit      /                                            \n        uint256 Launch_Time; // Launch_Time        \n        uint256 Deadline; // Deadline        \n    }\nstruct Bidding {\n        //      Bidding             \n        uint32 PriceInUnit; // PriceInUnit      \n        uint32 Quantity; // Quantity   /     \n        uint256 Bidding_Time; // Bidding_Time      \n        bool Liveness; // Liveness                                    \n    }\nstruct ExtractedFinal {\n        //     ExtractedFinal                                     \n        uint8 Bidder_Cindex; // Bidder_Cindex                     \n        uint32 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\nstruct TopBidder4seller {\n        //      TopBidder4seller                      \n        uint8 Bidder_index; // Bidder_index                     \n        uint8 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\n\n\nfunction RetractBidding() external AuctionOn OutsourseImmutability forbidOwner normalfunctioned {\n        RetractBidding_priv();\n    }\n\nfunction RetractBidding_priv() internal {\n        Biddinglist[msg.sender].Liveness = false;\n        Biddinglist[msg.sender].Bidding_Time = 0;\n    }\n\nmodifier AuctionOn() {\n        if (block.timestamp > orderdetail.Deadline) {\n            auction_state = false;\n            return;\n        } else {\n            _;\n        }\n    }\n\nmodifier normalfunctioned() {\n        require(!auction_retracted, \"The auction has been retracted.\");\n        _;\n    }\n\nmodifier OutsourseImmutability() {\n        require(msg.sender == tx.origin, \"You are not an external account in Ethereum.\");\n        _;\n    }\n\nmodifier forbidOwner() {\n        require(tx.origin != _owner, \"The creator himself should not interfere in the procedure of bidding.\");\n        _;\n    }}"
        },
        {
            "target_contract_name": "AuctionInstance",
            "target_func_name": "FindWinner",
            "original": " contract AuctionInstance{\n address[] BiddingAddress;\nbool auction_state = true;\nuint public BiddersNum;\nOrderDetail public orderdetail;\nbool auction_retracted = false;\naddress _owner;\nmapping(address => Bidding) Biddinglist;\nstruct OrderDetail {\n        //      OrderDetail                                      \n        string OrderInfo; // OrderInfo                                   \n        string Coal_Category; // Coal_Category      \n        uint256 Reserve_PriceInUnit; // Reserve_PriceInUnit      \n        uint256 Quantity; // Quantity       \n        uint256 Minimalsplit; // Minimalsplit      /                                            \n        uint256 Launch_Time; // Launch_Time        \n        uint256 Deadline; // Deadline        \n    }\nstruct Bidding {\n        //      Bidding             \n        uint32 PriceInUnit; // PriceInUnit      \n        uint32 Quantity; // Quantity   /     \n        uint256 Bidding_Time; // Bidding_Time      \n        bool Liveness; // Liveness                                    \n    }\nstruct ExtractedFinal {\n        //     ExtractedFinal                                     \n        uint8 Bidder_Cindex; // Bidder_Cindex                     \n        uint32 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\nstruct TopBidder4seller {\n        //      TopBidder4seller                      \n        uint8 Bidder_index; // Bidder_index                     \n        uint8 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\n\n\nfunction FindWinner(\n    ) public onlyOwner_self AuctionOff normalfunctioned returns (TopBidder4seller[] memory, address[] memory) {\n        uint8 TrunctionNumber = uint8(orderdetail.Quantity / orderdetail.Minimalsplit); \n        BiddingAddress = List_Sorting(BiddingAddress); \n        BiddersNum = BiddingAddress.length;\n        if (BiddersNum == 0) {\n            auction_state = false;\n            orderdetail.Deadline = orderdetail.Deadline + 86400;\n        }\n        ExtractedFinal[] memory SortedFinalBiddings = new ExtractedFinal[](TrunctionNumber);\n        for (uint8 i = 0; i < TrunctionNumber; i++) {\n            SortedFinalBiddings[i] = ExtractedFinal(0, 0);\n        }\n        for (uint j = 0; j < BiddersNum; j++) {\n            Bidding memory currentbidding = Biddinglist[BiddingAddress[j]]; \n            uint32 currentlinearizedbidding = CipherLinearization(currentbidding); \n            bool[] memory SortConditions = new bool[](TrunctionNumber + 1); \n            for (uint k = 0; k < TrunctionNumber; k++) {\n                SortConditions[k] = currentlinearizedbidding > SortedFinalBiddings[k].Linearized_Ciphertext;\n            }\n            SortConditions[TrunctionNumber] = false;\n            for (uint t = 0; t < TrunctionNumber; t++) {\n                ExtractedFinal memory currentprocessing = SortedFinalBiddings[t]; \n                SortedFinalBiddings[t] = ExtractedFinal(\n                        SortConditions[t] && !SortConditions[t + 1]? uint8(j):uint8(currentprocessing.Bidder_Cindex),\n                        SortConditions[t] && !SortConditions[t + 1]? currentlinearizedbidding: currentprocessing.Linearized_Ciphertext\n                );\n            }\n        }\n        TopBidder4seller[] memory SortedTopBidders4seller = new TopBidder4seller[](TrunctionNumber); \n        for (uint l = 0; l < TrunctionNumber; l++) {\n            SortedTopBidders4seller[l] = TopBidder4seller(\n                uint8(SortedFinalBiddings[l].Bidder_Cindex),\n               uint8(SortedFinalBiddings[l].Linearized_Ciphertext)\n            );\n        }\n     \n        return (SortedTopBidders4seller, BiddingAddress);\n    }\n\nmodifier AuctionOff() {\n        require(block.timestamp <= orderdetail.Deadline, \"The auction is still accepting biddings.\");\n        auction_state = false;\n        _;\n    }\n\nfunction List_Sorting(address[] memory biddingaddress) private view returns (address[] memory) {\n      \n        uint lengthoflist = biddingaddress.length;\n        uint nullindex = lengthoflist; \n        for (uint i = 0; i < lengthoflist - 1; i++) {\n            uint flagindex = i; \n            for (uint j = i + 1; j < lengthoflist - 2; j++) {\n                if (Biddinglist[biddingaddress[j]].Bidding_Time < Biddinglist[biddingaddress[flagindex]].Bidding_Time) {\n                    flagindex = j; \n                }\n            }\n            if (flagindex != i) {\n                (biddingaddress[i], biddingaddress[flagindex]) = (biddingaddress[flagindex], biddingaddress[i]);\n            }\n            if (Biddinglist[biddingaddress[i]].Bidding_Time == 0) {\n                nullindex = i;\n            }\n        }\n        if (nullindex != lengthoflist) {\n            address[] memory supportbiddingaddress = new address[](lengthoflist - nullindex - 1);\n            for (uint k = 0; k < lengthoflist - nullindex - 1; k++) {\n                supportbiddingaddress[k] = biddingaddress[k + nullindex + 1];\n            }\n            return supportbiddingaddress;\n        } else {\n            return biddingaddress;\n        }\n    }\n\nmodifier onlyOwner_self() {\n        require(isOwner_self(), \"You are not the creator of this auction contract.\");\n        _;\n    }\n\nfunction isOwner_self() internal view returns (bool) {\n        //               \n        return msg.sender == _owner;\n    }\n\nfunction CipherLinearization(Bidding memory bidding) private pure returns (uint32) {\n        uint32 conpensatedprice = bidding.PriceInUnit * 2 ^ 16; \n        return conpensatedprice + bidding.Quantity;\n    }\n\nmodifier normalfunctioned() {\n        require(!auction_retracted, \"The auction has been retracted.\");\n        _;\n    }}",
            "partition": " contract AuctionInstance{\n bool auction_retracted = false;\naddress _owner;\nmapping(address => Bidding) Biddinglist;\naddress[] BiddingAddress;\nbool auction_state = true;\nuint public BiddersNum;\nOrderDetail public orderdetail;\nstruct OrderDetail {\n        //      OrderDetail                                      \n        string OrderInfo; // OrderInfo                                   \n        string Coal_Category; // Coal_Category      \n        uint256 Reserve_PriceInUnit; // Reserve_PriceInUnit      \n        uint256 Quantity; // Quantity       \n        uint256 Minimalsplit; // Minimalsplit      /                                            \n        uint256 Launch_Time; // Launch_Time        \n        uint256 Deadline; // Deadline        \n    }\nstruct Bidding {\n        //      Bidding             \n        uint32 PriceInUnit; // PriceInUnit      \n        uint32 Quantity; // Quantity   /     \n        uint256 Bidding_Time; // Bidding_Time      \n        bool Liveness; // Liveness                                    \n    }\nstruct ExtractedFinal {\n        //     ExtractedFinal                                     \n        uint8 Bidder_Cindex; // Bidder_Cindex                     \n        uint32 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\nstruct TopBidder4seller {\n        //      TopBidder4seller                      \n        uint8 Bidder_index; // Bidder_index                     \n        uint8 Linearized_Ciphertext; // Linearized_Ciphertext         \n    }\n\n\nfunction FindWinner(\n    ) public onlyOwner_self AuctionOff normalfunctioned returns (TopBidder4seller[] memory, address[] memory) {\n        (TopBidder4seller[] memory SortedTopBidders4seller, address[] memory BiddingAddress) = FindWinner_priv();\n        return FindWinner_callback(SortedTopBidders4seller, BiddingAddress);\n    }\n\nmodifier normalfunctioned() {\n        require(!auction_retracted, \"The auction has been retracted.\");\n        _;\n    }\n\nfunction FindWinner_priv(\n    ) internal returns (TopBidder4seller[] memory, address[] memory) {\n        uint8 TrunctionNumber = uint8(orderdetail.Quantity / orderdetail.Minimalsplit); \n        BiddingAddress = List_Sorting(BiddingAddress); \n        BiddersNum = BiddingAddress.length;\n        if (BiddersNum == 0) {\n            auction_state = false;\n            orderdetail.Deadline = orderdetail.Deadline + 86400;\n        }\n        ExtractedFinal[] memory SortedFinalBiddings = new ExtractedFinal[](TrunctionNumber);\n        for (uint8 i = 0; i < TrunctionNumber; i++) {\n            SortedFinalBiddings[i] = ExtractedFinal(0, 0);\n        }\n        for (uint j = 0; j < BiddersNum; j++) {\n            Bidding memory currentbidding = Biddinglist[BiddingAddress[j]]; \n            uint32 currentlinearizedbidding = CipherLinearization(currentbidding); \n            bool[] memory SortConditions = new bool[](TrunctionNumber + 1); \n            for (uint k = 0; k < TrunctionNumber; k++) {\n                SortConditions[k] = currentlinearizedbidding > SortedFinalBiddings[k].Linearized_Ciphertext;\n            }\n            SortConditions[TrunctionNumber] = false;\n            for (uint t = 0; t < TrunctionNumber; t++) {\n                ExtractedFinal memory currentprocessing = SortedFinalBiddings[t]; \n                SortedFinalBiddings[t] = ExtractedFinal(\n                        SortConditions[t] && !SortConditions[t + 1]? uint8(j):uint8(currentprocessing.Bidder_Cindex),\n                        SortConditions[t] && !SortConditions[t + 1]? currentlinearizedbidding: currentprocessing.Linearized_Ciphertext\n                );\n            }\n        }\n        TopBidder4seller[] memory SortedTopBidders4seller = new TopBidder4seller[](TrunctionNumber); \n        for (uint l = 0; l < TrunctionNumber; l++) {\n            SortedTopBidders4seller[l] = TopBidder4seller(\n                uint8(SortedFinalBiddings[l].Bidder_Cindex),\n               uint8(SortedFinalBiddings[l].Linearized_Ciphertext)\n            );\n        }\n     \n        return (SortedTopBidders4seller, BiddingAddress);\n    }\n\nfunction List_Sorting(address[] memory biddingaddress) private view returns (address[] memory) {\n      \n        uint lengthoflist = biddingaddress.length;\n        uint nullindex = lengthoflist; \n        for (uint i = 0; i < lengthoflist - 1; i++) {\n            uint flagindex = i; \n            for (uint j = i + 1; j < lengthoflist - 2; j++) {\n                if (Biddinglist[biddingaddress[j]].Bidding_Time < Biddinglist[biddingaddress[flagindex]].Bidding_Time) {\n                    flagindex = j; \n                }\n            }\n            if (flagindex != i) {\n                (biddingaddress[i], biddingaddress[flagindex]) = (biddingaddress[flagindex], biddingaddress[i]);\n            }\n            if (Biddinglist[biddingaddress[i]].Bidding_Time == 0) {\n                nullindex = i;\n            }\n        }\n        if (nullindex != lengthoflist) {\n            address[] memory supportbiddingaddress = new address[](lengthoflist - nullindex - 1);\n            for (uint k = 0; k < lengthoflist - nullindex - 1; k++) {\n                supportbiddingaddress[k] = biddingaddress[k + nullindex + 1];\n            }\n            return supportbiddingaddress;\n        } else {\n            return biddingaddress;\n        }\n    }\n\nfunction CipherLinearization(Bidding memory bidding) private pure returns (uint32) {\n        uint32 conpensatedprice = bidding.PriceInUnit * 2 ^ 16; \n        return conpensatedprice + bidding.Quantity;\n    }\n\nfunction FindWinner_callback(TopBidder4seller[] memory SortedTopBidders4seller, address[] memory BiddingAddress\n    ) internal returns (TopBidder4seller[] memory, address[] memory) {\n      return (SortedTopBidders4seller, BiddingAddress);\n    }\n\nmodifier AuctionOff() {\n        require(block.timestamp <= orderdetail.Deadline, \"The auction is still accepting biddings.\");\n        auction_state = false;\n        _;\n    }\n\nmodifier onlyOwner_self() {\n        require(isOwner_self(), \"You are not the creator of this auction contract.\");\n        _;\n    }\n\nfunction isOwner_self() internal view returns (bool) {\n        //               \n        return msg.sender == _owner;\n    }}"
        }
    ],
    "ConfidentialAuction": [
        {
            "target_contract_name": "ConfidentialAuction",
            "target_func_name": "bid",
            "original": " contract ConfidentialAuction{\n mapping(address account => uint64 bidAmount) private bids;\nuint256 public endTime;\nuint256 public bidCounter;\nConfidentialERC20 public tokenContract;\nbool public manuallyStopped = false;\nuint64 private highestBid;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Winner(address who);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction bid(uint64 value) external onlyBeforeEnd {\n        uint64 existingBid = bids[msg.sender];\n        uint64 sentBalance;\n        if (existingBid==0) {\n            bidCounter++;\n            tokenContract.transferFrom(msg.sender, address(this), value);\n            bids[msg.sender] = value;\n        }\n        else if (existingBid >= highestBid)  {\n            bids[msg.sender] = value;\n            uint64 toTransfer = value - existingBid;\n            tokenContract.transferFrom(msg.sender, address(this), toTransfer);\n        } \n        uint64 currentBid = bids[msg.sender];\n\n        if (highestBid == 0 || existingBid >= highestBid) {\n            highestBid = currentBid;\n        } \n    }\n\nmodifier onlyBeforeEnd() {\n        if (block.timestamp >= endTime || manuallyStopped == true) revert TooLate(endTime);\n        _;\n    }}",
            "partition": " contract ConfidentialAuction{\n ConfidentialERC20 public tokenContract;\nbool public manuallyStopped = false;\nmapping(address account => uint64 bidAmount) private bids;\nuint64 private highestBid;\nuint256 public endTime;\nuint256 public bidCounter;\n\nevent Winner(address who);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction bid(uint64 value) external onlyBeforeEnd {\n       bool enable_bidCounter_increase = bid_priv(msg.sender, value);\n       bid_callback(enable_bidCounter_increase);\n    }\n\nfunction bid_callback(bool enable_bidCounter_increase) internal {\n        if (enable_bidCounter_increase) {\n            bidCounter++;\n        }\n    }\n\nmodifier onlyBeforeEnd() {\n        if (block.timestamp >= endTime || manuallyStopped == true) revert TooLate(endTime);\n        _;\n    }\n\nfunction bid_priv(address sender, uint64 value) internal returns (bool) {\n        bool enable_bidCounter_increase = false;\n        uint64 existingBid = bids[msg.sender];\n        uint64 sentBalance;\n        if (existingBid==0) {\n            enable_bidCounter_increase = true;\n            tokenContract.transferFrom(msg.sender, address(this), value);\n            bids[msg.sender] = value;\n        }\n        else if (existingBid >= highestBid)  {\n            bids[msg.sender] = value;\n            uint64 toTransfer = value - existingBid;\n            tokenContract.transferFrom(msg.sender, address(this), toTransfer);\n        } \n        uint64 currentBid = bids[msg.sender];\n\n        if (highestBid == 0 || existingBid >= highestBid) {\n            highestBid = currentBid;\n        } \n        return enable_bidCounter_increase;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialAuction",
            "target_func_name": "getBid",
            "original": " contract ConfidentialAuction{\n mapping(address account => uint64 bidAmount) private bids;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Winner(address who);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction getBid(address account) external view returns (uint64) {\n        return bids[account];\n    }}",
            "partition": " contract ConfidentialAuction{\n mapping(address account => uint64 bidAmount) private bids;\n\nevent Winner(address who);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction getBid(address account) external view returns (uint64) {\n        assert(msg.sender == account);\n        uint64 amt = getBid_priv(msg.sender);\n        return getBid_callback(amt);\n    }\n\nfunction getBid_priv(address account) internal view returns (uint64) {\n        uint64 amt = bids[account];\n        return amt;\n    }\n\nfunction getBid_callback(uint64 amt) internal pure returns (uint64) {\n        return amt;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialAuction",
            "target_func_name": "doIHaveHighestBid",
            "original": " contract ConfidentialAuction{\n mapping(address account => uint64 bidAmount) private bids;\nuint256 public endTime;\nbool public manuallyStopped = false;\nuint64 private highestBid;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Winner(address who);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction doIHaveHighestBid() public onlyAfterEnd returns (bool) {\n        if (\n            highestBid != 0 &&\n            bids[msg.sender] != 0\n        ) {\n            if (bids[msg.sender] >= highestBid)\n                return true; \n        }\n        return false;\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract ConfidentialAuction{\n uint64 private highestBid;\nbool public manuallyStopped = false;\nuint256 public endTime;\nmapping(address account => uint64 bidAmount) private bids;\n\nevent Winner(address who);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction doIHaveHighestBid() public onlyAfterEnd returns (bool) {\n       bool flag = doIHaveHighestBid_priv();\n       return doIHaveHighestBid_callback(flag);\n    }\n\nfunction doIHaveHighestBid_callback(bool flag) internal returns (bool) {\n        return flag;\n    }\n\nfunction doIHaveHighestBid_priv() internal  returns (bool) {\n        if (\n            highestBid != 0 &&\n            bids[msg.sender] != 0\n        ) {\n           \n            if (bids[msg.sender] >= highestBid)\n                return true; \n        }\n        return false;\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialAuction",
            "target_func_name": "claim",
            "original": " contract ConfidentialAuction{\n mapping(address account => uint64 bidAmount) private bids;\nuint256 public endTime;\nbool public manuallyStopped = false;\nuint64 private highestBid;\nbool private objectClaimed;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Winner(address who);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction claim() public onlyAfterEnd {\n        uint64 bidValue = bids[msg.sender];\n        if (bidValue >= highestBid && !objectClaimed ){\n            objectClaimed = true;\n            bids[msg.sender] = 0;\n            emit Winner(msg.sender);\n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract ConfidentialAuction{\n bool public manuallyStopped = false;\nmapping(address account => uint64 bidAmount) private bids;\nuint64 private highestBid;\nuint256 public endTime;\nbool private objectClaimed;\n\nevent Winner(address who);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction claim() public onlyAfterEnd {\n        require(!objectClaimed);\n        bool enable_claim = claim_priv();\n        claim_callback(enable_claim);\n    }\n\nfunction claim_callback(bool enable_claim) internal {\n        if (enable_claim){\n            objectClaimed = true;\n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }\n\nfunction claim_priv() internal returns (bool) {\n        bool enable_claim = false;\n        uint64 bidValue = bids[msg.sender];\n        if (bidValue >= highestBid){\n            enable_claim = true;\n            bids[msg.sender] = 0;\n        }\n        return enable_claim;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialAuction",
            "target_func_name": "auctionEnd",
            "original": " contract ConfidentialAuction{\n bool public tokenTransferred;\nuint256 public endTime;\naddress public beneficiary;\nConfidentialERC20 public tokenContract;\nbool public manuallyStopped = false;\nuint64 private highestBid;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Winner(address who);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction auctionEnd() public onlyAfterEnd {\n        require(!tokenTransferred);\n        tokenTransferred = true;\n        tokenContract.transfer(beneficiary, highestBid);\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract ConfidentialAuction{\n ConfidentialERC20 public tokenContract;\nbool public manuallyStopped = false;\nuint64 private highestBid;\nbool public tokenTransferred;\nuint256 public endTime;\naddress public beneficiary;\n\nevent Winner(address who);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction auctionEnd() public onlyAfterEnd {\n        require(!tokenTransferred);\n        auctionEnd_priv();\n        auctionEnd_callback();\n    }\n\nfunction auctionEnd_priv() internal {\n        tokenContract.transfer(beneficiary, highestBid);\n    }\n\nfunction auctionEnd_callback() internal {\n        tokenTransferred = true;\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialAuction",
            "target_func_name": "withdraw",
            "original": " contract ConfidentialAuction{\n mapping(address account => uint64 bidAmount) private bids;\nuint256 public endTime;\nConfidentialERC20 public tokenContract;\nbool public manuallyStopped = false;\nuint64 private highestBid;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Winner(address who);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction withdraw() public onlyAfterEnd {\n        uint64 bidValue = bids[msg.sender];\n        if (bidValue < highestBid){\n            tokenContract.transfer(msg.sender, bidValue);    \n            bids[msg.sender] = 0;\n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract ConfidentialAuction{\n ConfidentialERC20 public tokenContract;\nbool public manuallyStopped = false;\nmapping(address account => uint64 bidAmount) private bids;\nuint64 private highestBid;\nuint256 public endTime;\n\nevent Winner(address who);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction withdraw() public onlyAfterEnd {\n        withdraw_priv(msg.sender);\n    }\n\nfunction withdraw_priv(address sender) internal {\n        uint64 bidValue = bids[sender];\n        if (bidValue < highestBid){\n            tokenContract.transfer(sender, bidValue);  \n            bids[msg.sender] = 0;  \n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}"
        }
    ],
    "EncryptedERC20": [
        {
            "target_contract_name": "EncryptedERC20",
            "target_func_name": "mint",
            "original": " contract EncryptedERC20{\n uint64 private _totalSupply;\naddress private _owner;\nmapping(address => uint64) internal balances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction mint(uint64 mintedAmount) public virtual onlyOwner {\n        balances[owner()] = balances[owner()] + mintedAmount; // overflow impossible because of next line\n        _totalSupply = _totalSupply + mintedAmount;\n        emit Mint(owner(), mintedAmount);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}",
            "partition": " contract EncryptedERC20{\n uint64 private _totalSupply;\nmapping(address => uint64) internal balances;\naddress private _owner;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction mint(uint64 mintedAmount) public virtual onlyOwner {\n        mint_priv(mintedAmount);\n        _totalSupply = _totalSupply + mintedAmount;\n        emit Mint(owner(), mintedAmount);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction mint_priv(uint64 mintedAmount) internal virtual {\n        balances[owner()] = balances[owner()] + mintedAmount; // overflow impossible because of next line\n    }}"
        },
        {
            "target_contract_name": "EncryptedERC20",
            "target_func_name": "transfer",
            "original": " contract EncryptedERC20{\n mapping(address => uint64) internal balances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction transfer(address to, uint64 amount) public virtual returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal virtual {\n         // Make sure the sender has enough tokens.\n        bool isTransferable = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (isTransferable){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n        }\n    \n    }}",
            "partition": " contract EncryptedERC20{\n mapping(address => uint64) internal balances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction transfer(address to, uint64 amount) public virtual returns (bool) {\n        transfer_priv(msg.sender, to, amount);\n        return true;\n    }\n\nfunction transfer_priv(address sender, address to, uint64 amount) public virtual returns (bool) {\n        _transfer(sender, to, amount);\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal virtual {\n         // Make sure the sender has enough tokens.\n        bool isTransferable = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (isTransferable){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n        }\n    \n    }}"
        },
        {
            "target_contract_name": "EncryptedERC20",
            "target_func_name": "balanceOf",
            "original": " contract EncryptedERC20{\n mapping(address => uint64) internal balances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction balanceOf(address wallet) public view virtual returns (uint64) {\n        return balances[wallet];\n    }}",
            "partition": " contract EncryptedERC20{\n mapping(address => uint64) internal balances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction balanceOf(address wallet) public view virtual returns (uint64) {\n        uint64 bal =  balanceOf_priv(wallet);\n        return balanceOf_callback(bal);\n    }\n\nfunction balanceOf_callback(uint64 bal) public view virtual returns (uint64) {\n        return bal;\n    }\n\nfunction balanceOf_priv(address wallet) public view virtual returns (uint64) {\n        return balances[wallet];\n    }}"
        },
        {
            "target_contract_name": "EncryptedERC20",
            "target_func_name": "approve",
            "original": " contract EncryptedERC20{\n mapping(address => mapping(address => uint64)) internal allowances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction approve(address spender, uint64 amount) public virtual returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, amount);\n        emit Approval(owner, spender, amount);\n        return true;\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal virtual {\n        allowances[owner][spender] = amount;\n    }}",
            "partition": " contract EncryptedERC20{\n mapping(address => mapping(address => uint64)) internal allowances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction approve(address spender, uint64 amount) public virtual returns (bool) {\n        address owner = msg.sender;\n        approve_priv(owner, spender, amount);\n        return true;\n    }\n\nfunction approve_priv(address owner, address spender, uint64 amount) internal virtual returns (bool) {\n        _approve(owner, spender, amount);\n        emit Approval(owner, spender, amount);\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal virtual {\n        allowances[owner][spender] = amount;\n    }}"
        },
        {
            "target_contract_name": "EncryptedERC20",
            "target_func_name": "allowance",
            "original": " contract EncryptedERC20{\n mapping(address => mapping(address => uint64)) internal allowances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction allowance(address owner, address spender) public view virtual returns (uint64) {\n        return _allowance(owner, spender);\n    }\n\nfunction _allowance(address owner, address spender) internal view virtual returns (uint64) {\n        return allowances[owner][spender];\n    }}",
            "partition": " contract EncryptedERC20{\n mapping(address => mapping(address => uint64)) internal allowances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction allowance(address owner, address spender) public view virtual returns (uint64) {\n        require(msg.sender == owner || msg.sender == spender);\n        uint64 amt = allowance_priv(owner, spender);\n        return allowance_callback(amt);\n    }\n\nfunction allowance_priv(address owner, address spender) public view virtual returns (uint64) {\n        uint64 amt = _allowance(owner, spender);\n        return amt;\n    }\n\nfunction _allowance(address owner, address spender) internal view virtual returns (uint64) {\n        return allowances[owner][spender];\n    }\n\nfunction allowance_callback(uint64 amt) public view virtual returns (uint64) {\n        return amt;\n    }}"
        },
        {
            "target_contract_name": "EncryptedERC20",
            "target_func_name": "transferFrom",
            "original": " contract EncryptedERC20{\n mapping(address => mapping(address => uint64)) internal allowances;\nmapping(address => uint64) internal balances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction transferFrom(address from, address to, uint64 amount) public virtual returns (bool) {\n        address spender = msg.sender;\n        bool isTransferable = _updateAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal virtual {\n         // Make sure the sender has enough tokens.\n        bool isTransferable = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (isTransferable){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n        }\n    \n    }\n\nfunction _updateAllowance(address owner, address spender, uint64 amount) internal virtual returns (bool) {\n        uint64 currentAllowance = _allowance(owner, spender);\n        bool canApprove = amount <= currentAllowance;\n        if (canApprove) {\n            _approve(owner, spender, currentAllowance - amount);\n        }else{\n            _approve(owner, spender, 0);\n        }\n        return canApprove;\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal virtual {\n        allowances[owner][spender] = amount;\n    }\n\nfunction _allowance(address owner, address spender) internal view virtual returns (uint64) {\n        return allowances[owner][spender];\n    }}",
            "partition": " contract EncryptedERC20{\n mapping(address => mapping(address => uint64)) internal allowances;\nmapping(address => uint64) internal balances;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\nevent Mint(address indexed to, uint64 amount);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction transferFrom(address from, address to, uint64 amount) public virtual returns (bool) {\n        address spender = msg.sender;\n        transferFrom_priv(from, to, spender, amount);\n        return true;\n    }\n\nfunction transferFrom_priv(address from, address to, address spender, uint64 amount) public virtual returns (bool) {\n        bool isTransferable = _updateAllowance(from, spender, amount);\n        if (isTransferable) \n            _transfer(from, to, amount);\n    }\n\nfunction _updateAllowance(address owner, address spender, uint64 amount) internal virtual returns (bool) {\n        uint64 currentAllowance = _allowance(owner, spender);\n        bool canApprove = amount <= currentAllowance;\n        if (canApprove) {\n            _approve(owner, spender, currentAllowance - amount);\n        }else{\n            _approve(owner, spender, 0);\n        }\n        return canApprove;\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal virtual {\n        allowances[owner][spender] = amount;\n    }\n\nfunction _allowance(address owner, address spender) internal view virtual returns (uint64) {\n        return allowances[owner][spender];\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal virtual {\n         // Make sure the sender has enough tokens.\n        bool isTransferable = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (isTransferable){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n        }\n    \n    }}"
        }
    ],
    "NFTExample": [
        {
            "target_contract_name": "NFTExample",
            "target_func_name": "tokenURI",
            "original": " contract NFTExample{\n mapping(uint256 tokenId => uint64) private _tokenURIs;\n\nevent Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\nevent Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\nevent ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent MetadataUpdate(uint256 _tokenId);\nevent BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\nevent Minted(address indexed to, uint256 indexed tokenId);\nerror ERC721InvalidOwner(address owner);\nerror ERC721NonexistentToken(uint256 tokenId);\nerror ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\nerror ERC721InvalidSender(address sender);\nerror ERC721InvalidReceiver(address receiver);\nerror ERC721InsufficientApproval(address operator, uint256 tokenId);\nerror ERC721InvalidApprover(address approver);\nerror ERC721InvalidOperator(address operator);\nerror ERC721AlreadyMintedToken(uint256 tokenId);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction tokenURI(uint256 tokenId) public view virtual returns (uint64) {\n        return _tokenURIs[tokenId];\n    }}",
            "partition": " contract NFTExample{\n mapping(uint256 tokenId => uint64) private _tokenURIs;\nmapping(uint256 tokenId => address) private _owners;\n\nevent Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\nevent Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\nevent ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent MetadataUpdate(uint256 _tokenId);\nevent BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\nevent Minted(address indexed to, uint256 indexed tokenId);\nerror ERC721InvalidOwner(address owner);\nerror ERC721NonexistentToken(uint256 tokenId);\nerror ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\nerror ERC721InvalidSender(address sender);\nerror ERC721InvalidReceiver(address receiver);\nerror ERC721InsufficientApproval(address operator, uint256 tokenId);\nerror ERC721InvalidApprover(address approver);\nerror ERC721InvalidOperator(address operator);\nerror ERC721AlreadyMintedToken(uint256 tokenId);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction tokenURI(uint256 tokenId) public virtual returns (uint64) {\n        require(msg.sender == _ownerOf(tokenId)); // restrict only the owner of the token can disclassfy the results\n        uint64 uri = tokenURI_priv(tokenId);\n        return tokenURI_callback(uri);\n    }\n\nfunction tokenURI_callback(uint64 uri) internal virtual returns (uint64) {\n        return uri;\n    }\n\nfunction tokenURI_priv(uint256 tokenId) internal virtual returns (uint64) {\n        return _tokenURIs[tokenId];\n    }\n\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }}"
        },
        {
            "target_contract_name": "NFTExample",
            "target_func_name": "setTokenURI",
            "original": " contract NFTExample{\n mapping(uint256 tokenId => uint64) private _tokenURIs;\nmapping(uint256 tokenId => address) private _owners;\n\nevent Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\nevent Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\nevent ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent MetadataUpdate(uint256 _tokenId);\nevent BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\nevent Minted(address indexed to, uint256 indexed tokenId);\nerror ERC721InvalidOwner(address owner);\nerror ERC721NonexistentToken(uint256 tokenId);\nerror ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\nerror ERC721InvalidSender(address sender);\nerror ERC721InvalidReceiver(address receiver);\nerror ERC721InsufficientApproval(address operator, uint256 tokenId);\nerror ERC721InvalidApprover(address approver);\nerror ERC721InvalidOperator(address operator);\nerror ERC721AlreadyMintedToken(uint256 tokenId);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction setTokenURI(\n        uint256 tokenId,\n        uint64 _tokenURI\n    ) public {\n        _requireOwned(tokenId);\n        address owner = _ownerOf(tokenId);\n        if (msg.sender != owner) {\n            revert ERC721IncorrectOwner(msg.sender, tokenId, owner);\n        }\n\n        _setTokenURI(owner, tokenId, _tokenURI);\n    }\n\nfunction _setTokenURI(\n        address to,\n        uint256 tokenId,\n        uint64 _tokenURI\n    ) internal virtual {\n        _tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }}",
            "partition": " contract NFTExample{\n mapping(uint256 tokenId => uint64) private _tokenURIs;\nmapping(uint256 tokenId => address) private _owners;\n\nevent Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\nevent Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\nevent ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent MetadataUpdate(uint256 _tokenId);\nevent BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\nevent Minted(address indexed to, uint256 indexed tokenId);\nerror ERC721InvalidOwner(address owner);\nerror ERC721NonexistentToken(uint256 tokenId);\nerror ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\nerror ERC721InvalidSender(address sender);\nerror ERC721InvalidReceiver(address receiver);\nerror ERC721InsufficientApproval(address operator, uint256 tokenId);\nerror ERC721InvalidApprover(address approver);\nerror ERC721InvalidOperator(address operator);\nerror ERC721AlreadyMintedToken(uint256 tokenId);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction setTokenURI(\n        uint256 tokenId,\n        uint64 _tokenURI\n    ) public {\n        _requireOwned(tokenId);\n        address owner = _ownerOf(tokenId);\n        if (msg.sender != owner) {\n            revert ERC721IncorrectOwner(msg.sender, tokenId, owner);\n        }\n        setTokenURI_priv(owner, tokenId, _tokenURI);\n    }\n\nfunction setTokenURI_priv(\n        address owner,\n        uint256 tokenId,\n        uint64 _tokenURI\n    ) public {\n        _setTokenURI(owner, tokenId, _tokenURI);\n    }\n\nfunction _setTokenURI(\n        address to,\n        uint256 tokenId,\n        uint64 _tokenURI\n    ) internal virtual {\n        _tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }}"
        }
    ],
    "Battleship": [
        {
            "target_contract_name": "Battleship",
            "target_func_name": "placeShips",
            "original": " contract Battleship{\n uint8[4][4] public player1Board;\nuint8 public constant BOARD_SIZE = 4;\naddress public player2;\nbool public gameReady;\naddress public player1;\nbool public gameEnded;\nbool public player2Ready;\nuint8[4][4] public player2Board;\nbool public player1Ready;\n\nevent Attack(uint8 x, uint8 y, address victim, bool hit);\nevent GameEnded(address winner);\n\nfunction placeShips(uint32 packedData) public onlyPlayers {\n        require(!gameEnded, \"Game has ended\");\n        require(!gameReady, \"Boards already set\");\n\n        // values are encoded as bits from right to left\n        // 0 = empty\n        // 1 = ship\n        //\n        // example input:\n        //\n        // 0010001011001100\n        //\n        // results in the following board:\n        //\n        // 0 0 1 1\n        // 0 0 1 1\n        // 0 1 0 0\n        // 0 1 0 0\n\n        uint8[BOARD_SIZE][BOARD_SIZE] storage board;\n        if(msg.sender == player1  ){\n            board = player1Board;\n        } else {\n            board = player2Board;\n        }\n        uint8 mask = 1;\n        uint8 shipCount = 0;\n\n        for (uint256 i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {\n          uint8 value = uint8(packedData & mask);\n          board[i / BOARD_SIZE][i % BOARD_SIZE] = value;\n          shipCount = shipCount + value;\n\n          packedData = packedData >> 1;\n        }\n\n        // Make sure the user created 6 ships\n        require(shipCount == 6);\n\n        if (msg.sender == player1) {\n            player1Ready = true;\n        } else {\n            player2Ready = true;\n        }\n\n        if (player2Ready && player1Ready) {\n            gameReady = true;\n        }\n    }\n\nmodifier onlyPlayers() {\n        require(msg.sender == player1 || msg.sender == player2, \"Only players can call this function\");\n        _;\n    }}",
            "partition": " contract Battleship{\n bool public gameEnded;\nuint8 public constant BOARD_SIZE = 4;\naddress public player2;\nuint8[4][4] public player2Board;\nbool public gameReady;\nbool public player1Ready;\nbool public player2Ready;\naddress public player1;\nuint8[4][4] public player1Board;\n\nevent Attack(uint8 x, uint8 y, address victim, bool hit);\nevent GameEnded(address winner);\n\nfunction placeShips(uint32 packedData) public onlyPlayers {\n        require(!gameEnded, \"Game has ended\");\n        require(!gameReady, \"Boards already set\");\n\n        // values are encoded as bits from right to left\n        // 0 = empty\n        // 1 = ship\n        //\n        // example input:\n        //\n        // 0010001011001100\n        //\n        // results in the following board:\n        //\n        // 0 0 1 1\n        // 0 0 1 1\n        // 0 1 0 0\n        // 0 1 0 0\n        bool isPlayer1;\n        if(msg.sender == player1  ){\n            isPlayer1 = true;\n        } else {\n            isPlayer1 = false;\n        }\n\n        placeShips_priv(isPlayer1, packedData);\n        placeShips_callback(msg.sender);\n    }\n\nmodifier onlyPlayers() {\n        require(msg.sender == player1 || msg.sender == player2, \"Only players can call this function\");\n        _;\n    }\n\nfunction placeShips_callback(address sender) internal {\n        if (sender == player1) {\n            player1Ready = true;\n        } else {\n            player2Ready = true;\n        }\n\n        if (player2Ready && player1Ready) {\n            gameReady = true;\n        }\n    }\n\nfunction placeShips_priv(bool isPlayer1, uint32 packedData) internal  returns (bool) {\n        uint8[BOARD_SIZE][BOARD_SIZE] storage board;\n        if(isPlayer1){\n            board = player1Board;\n        } else {\n            board = player2Board;\n        }\n        uint8 mask = 1;\n        uint8 shipCount = 0;\n\n        for (uint256 i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {\n          uint8 value = uint8(packedData & mask);\n          board[i / BOARD_SIZE][i % BOARD_SIZE] = value;\n          shipCount = shipCount + value;\n\n          packedData = packedData >> 1;\n        }\n\n        // Make sure the user created 6 ships\n        require(shipCount == 6);\n        return true;\n    }}"
        },
        {
            "target_contract_name": "Battleship",
            "target_func_name": "attack",
            "original": " contract Battleship{\n uint8[4][4] public player1Board;\nuint8 public player1ShipsHit;\naddress public player2;\naddress public currentPlayer;\nbool public gameReady;\naddress public winner;\naddress public player1;\nbool public gameEnded;\nuint8[4][4] public player2Board;\nuint8 public player2ShipsHit;\n\nevent Attack(uint8 x, uint8 y, address victim, bool hit);\nevent GameEnded(address winner);\n\nfunction attack(uint8 _x, uint8 _y) public onlyPlayers {\n        require(gameReady, \"Game not ready\");\n        require(!gameEnded, \"Game has ended\");\n        require(msg.sender == currentPlayer, \"Not your turn\");\n\n        uint8[4][4] storage targetBoard;\n        if (msg.sender == player1) {\n            targetBoard = player2Board;\n        } else {\n            targetBoard = player1Board;\n        }\n\n        uint8 target = targetBoard[_x][_y];\n        require(target < 2, \"Already attacked this cell\");\n\n        if (target == 1) {\n            if (msg.sender == player1) {\n                player2ShipsHit++;\n                emit Attack(_x, _y, player2, true);\n            } else {\n                player1ShipsHit++;\n                emit Attack(_x, _y, player1, true);\n            }\n            if (player1ShipsHit == 6 || player2ShipsHit == 6) {\n                gameEnded = true;\n                winner = msg.sender;\n                emit GameEnded(msg.sender);\n            }\n        } else {\n            if (msg.sender == player1) {\n                emit Attack(_x, _y, player2, false);\n            } else {\n                emit Attack(_x, _y, player1, false);\n            }\n        }\n        targetBoard[_x][_y] = 2;\n\n        if (currentPlayer == player1) {\n            currentPlayer = player2;\n        } else {\n            currentPlayer = player1;\n        }\n    }\n\nmodifier onlyPlayers() {\n        require(msg.sender == player1 || msg.sender == player2, \"Only players can call this function\");\n        _;\n    }}",
            "partition": " contract Battleship{\n bool public gameEnded;\naddress public player2;\nuint8[4][4] public player2Board;\nbool public gameReady;\nuint8 public player1ShipsHit;\naddress public currentPlayer;\nuint8 public player2ShipsHit;\naddress public winner;\naddress public player1;\nuint8[4][4] public player1Board;\n\nevent Attack(uint8 x, uint8 y, address victim, bool hit);\nevent GameEnded(address winner);\n\nfunction attack(uint8 _x, uint8 _y) public onlyPlayers {\n        require(gameReady, \"Game not ready\");\n        require(!gameEnded, \"Game has ended\");\n        require(msg.sender == currentPlayer, \"Not your turn\");\n\n        bool isPlayer1;\n        if(msg.sender == player1  ){\n            isPlayer1 = true;\n        } else {\n            isPlayer1 = false;\n        }\n\n        bool my_gameEnded = attack_priv(isPlayer1, _x, _y);\n        attack_callback(msg.sender, my_gameEnded);\n    }\n\nmodifier onlyPlayers() {\n        require(msg.sender == player1 || msg.sender == player2, \"Only players can call this function\");\n        _;\n    }\n\nfunction attack_callback(address sender, bool my_gameEnded) internal {\n        if (my_gameEnded){\n            gameEnded = true;\n            winner = sender;\n            emit GameEnded(msg.sender);\n        }\n\n        if (currentPlayer == player1) {\n            currentPlayer = player2;\n        } else {\n            currentPlayer = player1;\n        }\n    }\n\nfunction attack_priv(bool isPlayer1, uint8 _x, uint8 _y) internal returns (bool) {\n        bool my_gameEnded = false;\n        uint8[4][4] storage targetBoard;\n        if (isPlayer1) {\n            targetBoard = player2Board;\n        } else {\n            targetBoard = player1Board;\n        }\n\n        uint8 target = targetBoard[_x][_y];\n        require(target < 2, \"Already attacked this cell\");\n\n        if (target == 1) {\n            if (isPlayer1) {\n                player2ShipsHit++;\n                emit Attack(_x, _y, player2, true);\n            } else {\n                player1ShipsHit++;\n                emit Attack(_x, _y, player1, true);\n            }\n            if (player1ShipsHit == 6 || player2ShipsHit == 6) {\n                my_gameEnded = true;\n            }\n        } else {\n            if (isPlayer1) {\n                emit Attack(_x, _y, player2, false);\n            } else {\n                emit Attack(_x, _y, player1, false);\n            }\n        }\n        targetBoard[_x][_y] = 2;\n        return my_gameEnded;\n    }}"
        }
    ],
    "ConfidentialERC20": [
        {
            "target_contract_name": "ConfidentialERC20",
            "target_func_name": "balanceOf",
            "original": " contract ConfidentialERC20{\n mapping(address => uint64) internal balances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction balanceOf() public view virtual returns (uint64 balance) {\n        return balances[msg.sender];\n    }}",
            "partition": " contract ConfidentialERC20{\n mapping(address => uint64) internal balances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction balanceOf() public view virtual returns (uint64 balance) {\n        uint64 bal = balanceOf_priv(msg.sender);\n        return balanceOf_callback(bal);\n    }\n\nfunction balanceOf_callback(uint64 bal) internal view virtual returns (uint64 balance) {\n        return bal;\n    }\n\nfunction balanceOf_priv(address sender) internal view virtual returns (uint64 balance) {\n        return balances[sender];\n    }}"
        },
        {
            "target_contract_name": "ConfidentialERC20",
            "target_func_name": "transfer",
            "original": " contract ConfidentialERC20{\n mapping(address => uint64) internal balances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction transfer(\n        address _to,\n        uint64 _value\n    ) public virtual returns (bool success) {\n        bool result = contractTransfer(_to, _value);\n        return result;\n    }\n\nfunction contractTransfer(\n        address _to,\n        uint64 _value\n    ) internal virtual returns (bool success) {\n        (uint64 fromBalance, uint64 toBalance) = getBalances(\n            msg.sender,\n            _to\n        );\n        uint64 newFromBalance = fromBalance - _value;\n        uint64 newToBalance = toBalance + _value;\n\n        emit Transfer(msg.sender, _to);\n        setNewBalances(msg.sender, _to, newFromBalance, newToBalance);\n\n        return true;\n    }\n\nfunction getBalances(\n        address _from,\n        address _to\n    ) private view returns (uint64, uint64) {\n        uint64 fromBalance = balances[_from];\n        uint64 toBalance = balances[_to];\n        return (fromBalance, toBalance);\n    }\n\nfunction setNewBalances(\n        address _from,\n        address _to,\n        uint64 newFromBalance,\n        uint64 newToBalance\n    ) private {\n        // Convert the uint64 to uint64 and store it in the balances mapping\n        balances[_from] = newFromBalance;\n        balances[_to] = newToBalance;\n    }}",
            "partition": " contract ConfidentialERC20{\n mapping(address => uint64) internal balances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction transfer(\n        address _to,\n        uint64 _value\n    ) public virtual returns (bool success) {\n        transfer_priv(msg.sender, _to, _value);\n        return true;\n    }\n\nfunction transfer_priv(address from, address to, uint64 amount) internal {\n       contractTransfer(from, to, amount); \n    }\n\nfunction contractTransfer(\n        address _from,\n        address _to,\n        uint64 _value\n    ) internal virtual returns (bool success) {\n        (uint64 fromBalance, uint64 toBalance) = getBalances(\n            _from,\n            _to\n        );\n        uint64 newFromBalance = fromBalance - _value;\n        uint64 newToBalance = toBalance + _value;\n\n        emit Transfer(_from, _to);\n        setNewBalances(_from, _to, newFromBalance, newToBalance);\n\n        return true;\n    }\n\nfunction setNewBalances(\n        address _from,\n        address _to,\n        uint64 newFromBalance,\n        uint64 newToBalance\n    ) private {\n        // Convert the uint64 to uint64 and store it in the balances mapping\n        balances[_from] = newFromBalance;\n        balances[_to] = newToBalance;\n    }\n\nfunction getBalances(\n        address _from,\n        address _to\n    ) private returns (uint64, uint64) {\n        uint64 fromBalance = balances[_from];\n        uint64 toBalance = balances[_to];\n        return (fromBalance, toBalance);\n    }}"
        },
        {
            "target_contract_name": "ConfidentialERC20",
            "target_func_name": "transferFrom",
            "original": " contract ConfidentialERC20{\n mapping(address => mapping(address => uint64)) private allowances;\nmapping(address => uint64) internal balances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction transferFrom(\n        address _from,\n        address _to,\n        uint64 _value\n    ) public virtual returns (bool success) {\n        // Create IT from ciphertext and signature\n        \n        bool result = contractTransferFrom(\n            _from,\n            _to,\n            _value\n        );\n        return result;\n    }\n\nfunction contractTransferFrom(\n        address _from,\n        address _to,\n        uint64 _value\n    ) internal virtual returns (bool success) {\n        (uint64 fromBalance, uint64 toBalance) = getBalances(_from, _to);\n        uint64 allowanceAmount = getGTAllowance(_from, _to);\n        \n        uint64 newFromBalance = fromBalance - _value;\n        uint64 newToBalance = toBalance + _value;\n        uint64 newAllowance = allowanceAmount - _value;\n      \n        setApproveValue(_from, _to, newAllowance);\n        emit Transfer(_from, _to);\n        setNewBalances(_from, _to, newFromBalance, newToBalance);\n\n        return true;\n    }\n\nfunction getBalances(\n        address _from,\n        address _to\n    ) private view returns (uint64, uint64) {\n        uint64 fromBalance = balances[_from];\n        uint64 toBalance = balances[_to];\n        return (fromBalance, toBalance);\n    }\n\nfunction setApproveValue(\n        address _owner,\n        address _spender,\n        uint64 _value\n    ) private {\n        allowances[_owner][_spender] = _value;\n    }\n\nfunction getGTAllowance(\n        address _owner,\n        address _spender\n    ) private returns (uint64 remaining) {\n        return allowances[_owner][_spender];\n    }\n\nfunction setNewBalances(\n        address _from,\n        address _to,\n        uint64 newFromBalance,\n        uint64 newToBalance\n    ) private {\n        // Convert the uint64 to uint64 and store it in the balances mapping\n        balances[_from] = newFromBalance;\n        balances[_to] = newToBalance;\n    }}",
            "partition": " contract ConfidentialERC20{\n mapping(address => uint64) internal balances;\nmapping(address => mapping(address => uint64)) private allowances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction transferFrom(\n        address _from,\n        address _to,\n        uint64 _value\n    ) public virtual returns (bool success) {\n        // Create IT from ciphertext and signature\n        transferFrom_priv(_from, _to, _value);\n        return true;\n    }\n\nfunction transferFrom_priv(address _from, address _to, uint64 _value) internal returns (bool) {\n        bool result = contractTransferFrom(\n            _from,\n            _to,\n            _value\n        );\n        return result;\n    }\n\nfunction contractTransferFrom(\n        address _from,\n        address _to,\n        uint64 _value\n    ) internal virtual returns (bool success) {\n        (uint64 fromBalance, uint64 toBalance) = getBalances(_from, _to);\n        uint64 allowanceAmount = getGTAllowance(_from, _to);\n        \n        uint64 newFromBalance = fromBalance - _value;\n        uint64 newToBalance = toBalance + _value;\n        uint64 newAllowance = allowanceAmount - _value;\n      \n        setApproveValue(_from, _to, newAllowance);\n        emit Transfer(_from, _to);\n        setNewBalances(_from, _to, newFromBalance, newToBalance);\n\n        return true;\n    }\n\nfunction getGTAllowance(\n        address _owner,\n        address _spender\n    ) private returns (uint64 remaining) {\n        return allowances[_owner][_spender];\n    }\n\nfunction setNewBalances(\n        address _from,\n        address _to,\n        uint64 newFromBalance,\n        uint64 newToBalance\n    ) private {\n        // Convert the uint64 to uint64 and store it in the balances mapping\n        balances[_from] = newFromBalance;\n        balances[_to] = newToBalance;\n    }\n\nfunction setApproveValue(\n        address _owner,\n        address _spender,\n        uint64 _value\n    ) private {\n        allowances[_owner][_spender] = _value;\n    }\n\nfunction getBalances(\n        address _from,\n        address _to\n    ) private returns (uint64, uint64) {\n        uint64 fromBalance = balances[_from];\n        uint64 toBalance = balances[_to];\n        return (fromBalance, toBalance);\n    }}"
        },
        {
            "target_contract_name": "ConfidentialERC20",
            "target_func_name": "approve",
            "original": " contract ConfidentialERC20{\n mapping(address => mapping(address => uint64)) private allowances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction approve(\n        address _spender,\n        uint64 _value\n    ) public virtual returns (bool success) {\n        address owner = msg.sender;\n        setApproveValue(owner, _spender, _value);\n        emit Approval(owner, _spender);\n        return true;\n    }\n\nfunction setApproveValue(\n        address _owner,\n        address _spender,\n        uint64 _value\n    ) private {\n        allowances[_owner][_spender] = _value;\n    }}",
            "partition": " contract ConfidentialERC20{\n mapping(address => mapping(address => uint64)) private allowances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction approve(\n        address _spender,\n        uint64 _value\n    ) public virtual returns (bool success) {\n        address owner = msg.sender;\n        approve_priv(owner, _spender, _value);\n        return true;\n    }\n\nfunction approve_priv(address owner, address _spender, uint64 _value) internal  {\n        setApproveValue(owner, _spender, _value);\n        emit Approval(owner, _spender);\n    }\n\nfunction setApproveValue(\n        address _owner,\n        address _spender,\n        uint64 _value\n    ) private {\n        allowances[_owner][_spender] = _value;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialERC20",
            "target_func_name": "allowance",
            "original": " contract ConfidentialERC20{\n mapping(address => mapping(address => uint64)) private allowances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction allowance(\n        address _owner,\n        address _spender\n    ) public view virtual returns (uint64 remaining) {\n        require(_owner == msg.sender || _spender == msg.sender);\n\n        return allowances[_owner][_spender];\n    }}",
            "partition": " contract ConfidentialERC20{\n mapping(address => mapping(address => uint64)) private allowances;\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Transfer(address indexed _from, address indexed _to);\nevent Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\nevent Approval(address indexed _owner, address indexed _spender);\n\nfunction allowance(\n        address _owner,\n        address _spender\n    ) public view virtual returns (uint64 remaining) {\n        require(_owner == msg.sender || _spender == msg.sender);\n        uint64 amt = allowance_priv(_owner, _spender);\n        return allowance_callback(amt);\n    }\n\nfunction allowance_priv(address _owner, address _spender) public view virtual returns (uint64) {\n        return allowances[_owner][_spender];\n    }\n\nfunction allowance_callback(uint64 amt) public view virtual returns (uint64) {\n        return amt;\n    }}"
        }
    ],
    "EncryptedFunds": [
        {
            "target_contract_name": "EncryptedFunds",
            "target_func_name": "totalSupply",
            "original": " contract EncryptedFunds{\n mapping(uint64 => uint64) private totalSupplyPerToken;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction totalSupply(uint64 encryptedTokenID) public view returns (uint64) {\n        return totalSupplyPerToken[encryptedTokenID];\n    }}",
            "partition": " contract EncryptedFunds{\n mapping(uint64 => uint64) private totalSupplyPerToken;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction totalSupply(uint64 encryptedTokenID) public view returns (uint64) {\n        uint64 bal = totalSupply_priv(encryptedTokenID);\n        return totalSupply_callback(bal);\n    }\n\nfunction totalSupply_callback(uint64 bal) internal pure returns (uint64) {\n        return bal;\n    }\n\nfunction totalSupply_priv(uint64 encryptedTokenID) internal view returns (uint64) {\n        return totalSupplyPerToken[encryptedTokenID];\n    }}"
        },
        {
            "target_contract_name": "EncryptedFunds",
            "target_func_name": "mint",
            "original": " contract EncryptedFunds{\n mapping(uint64 => uint64) private totalSupplyPerToken;\naddress private _owner;\nmapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction mint(uint64 encryptedTokenID, uint64 mintedAmount) public virtual onlyOwner {\n        balances[owner()][encryptedTokenID] =balances[owner()][encryptedTokenID] + mintedAmount;\n        // Update the total supply for the specific token\n        totalSupplyPerToken[encryptedTokenID] = totalSupplyPerToken[encryptedTokenID] + mintedAmount;\n        emit Mint(owner(), encryptedTokenID, mintedAmount);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}",
            "partition": " contract EncryptedFunds{\n mapping(uint64 => uint64) private totalSupplyPerToken;\naddress private _owner;\nmapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction mint(uint64 encryptedTokenID, uint64 mintedAmount) public virtual onlyOwner {\n        mint_priv(owner(), encryptedTokenID, mintedAmount);\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction mint_priv(address sender, uint64 encryptedTokenID, uint64 mintedAmount) internal {\n        balances[sender][encryptedTokenID] =balances[sender][encryptedTokenID] + mintedAmount;\n        // Update the total supply for the specific token\n        totalSupplyPerToken[encryptedTokenID] = totalSupplyPerToken[encryptedTokenID] + mintedAmount;\n        emit Mint(sender, encryptedTokenID, mintedAmount);\n    }}"
        },
        {
            "target_contract_name": "EncryptedFunds",
            "target_func_name": "burn",
            "original": " contract EncryptedFunds{\n mapping(uint64 => uint64) private totalSupplyPerToken;\naddress private _owner;\nmapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction burn(uint64 encryptedTokenID, uint64 mintedAmount) public virtual onlyOwner {\n        balances[owner()][encryptedTokenID] = balances[owner()][encryptedTokenID] - mintedAmount;\n      \n        totalSupplyPerToken[encryptedTokenID] = totalSupplyPerToken[encryptedTokenID] - mintedAmount;\n        emit Mint(owner(), encryptedTokenID, mintedAmount);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}",
            "partition": " contract EncryptedFunds{\n mapping(uint64 => uint64) private totalSupplyPerToken;\naddress private _owner;\nmapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction burn(uint64 encryptedTokenID, uint64 mintedAmount) public virtual onlyOwner {\n       burn_priv(owner(), encryptedTokenID, mintedAmount);\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction burn_priv(address sender, uint64 encryptedTokenID, uint64 mintedAmount) public virtual onlyOwner {\n        balances[sender][encryptedTokenID] = balances[sender][encryptedTokenID] - mintedAmount;\n      \n        totalSupplyPerToken[encryptedTokenID] = totalSupplyPerToken[encryptedTokenID] - mintedAmount;\n        emit Mint(sender, encryptedTokenID, mintedAmount);\n    }}"
        },
        {
            "target_contract_name": "EncryptedFunds",
            "target_func_name": "approve",
            "original": " contract EncryptedFunds{\n mapping(uint256 => uint64) private encryptedTokenIDs;\nmapping(address => mapping(address => mapping(uint64 => uint64))) internal allowances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction approve(address spender, uint64 encryptedTokenID, uint64 amount) public virtual returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, encryptedTokenID, amount);\n        emit Approval(owner, spender);\n        return true;\n    }\n\nfunction _approve(address owner, address spender, uint64 encryptedTokenID, uint64 amount) internal virtual {\n        for (uint256 i = 0; i < _getNumberOfTokens(); i++) {\n            uint64 currentTokenID = encryptedTokenIDs[i];\n            bool isCorrectToken = encryptedTokenID == currentTokenID;\n            uint64 currentAllowance = allowances[owner][spender][currentTokenID];\n            uint64 newAllowance = isCorrectToken? amount: currentAllowance;\n            allowances[owner][spender][currentTokenID] = newAllowance;\n        }\n    }\n\nfunction _getNumberOfTokens() internal pure returns (uint256) {\n        return 3; // Example with 3 tokens (extendable if needed)\n    }}",
            "partition": " contract EncryptedFunds{\n mapping(uint256 => uint64) private encryptedTokenIDs;\nmapping(address => mapping(address => mapping(uint64 => uint64))) internal allowances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction approve(address spender, uint64 encryptedTokenID, uint64 amount) public virtual returns (bool) {\n        address owner = msg.sender;\n        bool flag = approve_priv(spender, owner, encryptedTokenID, amount);\n        return approve_callback(flag);\n    }\n\nfunction approve_callback(bool flag) internal pure returns (bool) {\n       return flag; \n    }\n\nfunction approve_priv(address spender, address owner, uint64 encryptedTokenID, uint64 amount) internal returns (bool) {\n        _approve(owner, spender, encryptedTokenID, amount);\n        emit Approval(owner, spender);\n        return true;\n    }\n\nfunction _approve(address owner, address spender, uint64 encryptedTokenID, uint64 amount) internal virtual {\n        for (uint256 i = 0; i < _getNumberOfTokens(); i++) {\n            uint64 currentTokenID = encryptedTokenIDs[i];\n            bool isCorrectToken = encryptedTokenID == currentTokenID;\n            uint64 currentAllowance = allowances[owner][spender][currentTokenID];\n            uint64 newAllowance = isCorrectToken? amount: currentAllowance;\n            allowances[owner][spender][currentTokenID] = newAllowance;\n        }\n    }\n\nfunction _getNumberOfTokens() internal pure returns (uint256) {\n        return 3; // Example with 3 tokens (extendable if needed)\n    }}"
        },
        {
            "target_contract_name": "EncryptedFunds",
            "target_func_name": "transferFrom",
            "original": " contract EncryptedFunds{\n mapping(uint256 => uint64) private encryptedTokenIDs;\nmapping(address => mapping(address => mapping(uint64 => uint64))) internal allowances;\nmapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction transferFrom(\n        address from,\n        address to,\n        uint64 encryptedTokenID,\n        uint64 amount\n    ) public virtual returns (bool) {\n        address spender = msg.sender;\n        _transferHidden(from, to, spender, encryptedTokenID, amount);\n        return true;\n    }\n\nfunction _transferHidden(\n        address from,\n        address to,\n        address spender,\n        uint64 encryptedTokenID,\n        uint64 amount\n    ) internal virtual {\n        for (uint256 i = 0; i < _getNumberOfTokens(); i++) {\n            uint64 currentTokenID = encryptedTokenIDs[i];\n            emit TokenAccessed(currentTokenID);\n            _checkAndTransferBalances(from, to, spender, currentTokenID, encryptedTokenID, amount);\n        }\n        emit Transfer(from, to);\n    }\n\nfunction _checkAndTransferBalances(\n        address from,\n        address to,\n        address spender,\n        uint64 currentTokenID,\n        uint64 encryptedTokenID,\n        uint64 amount\n    ) internal {\n        bool isCorrectToken = encryptedTokenID == currentTokenID;\n        uint64 currentBalance = balances[from][currentTokenID];\n        uint64 currentAllowance = _allowance(from, spender, currentTokenID);\n        emit BalanceBeforeTransfer(currentTokenID, currentBalance, currentAllowance);\n\n        bool allowedTransfer = amount <= currentAllowance;\n        bool canTransfer = amount <= currentBalance;\n        bool isTransferable = canTransfer && allowedTransfer;\n\n        uint64 updatedAllowance = isTransferable?currentAllowance -amount : currentAllowance;\n        allowances[from][spender][currentTokenID] = updatedAllowance;\n\n        uint64 transferAmount = isCorrectToken? amount: 0;\n        uint64 transferValue = isTransferable? transferAmount:0;\n\n        emit TransferValue(currentTokenID, transferValue);\n\n        _updateBalances(from, to, currentTokenID, transferValue);\n    }\n\nfunction _allowance(\n        address owner,\n        address spender,\n        uint64 encryptedTokenID\n    ) internal view virtual returns (uint64) {\n        return allowances[owner][spender][encryptedTokenID];\n    }\n\nfunction _updateBalances(address from, address to, uint64 currentTokenID, uint64 transferValue) internal {\n        uint64 newBalanceTo = balances[to][currentTokenID] + transferValue;\n        balances[to][currentTokenID] = newBalanceTo;\n\n        uint64 newBalanceFrom = balances[from][currentTokenID] - transferValue;\n        balances[from][currentTokenID] = newBalanceFrom;\n\n        emit BalanceAfterTransfer(\n            currentTokenID,\n            newBalanceTo,\n            newBalanceFrom,\n            allowances[from][msg.sender][currentTokenID]\n        );\n    }\n\nfunction _getNumberOfTokens() internal pure returns (uint256) {\n        return 3; // Example with 3 tokens (extendable if needed)\n    }}",
            "partition": " contract EncryptedFunds{\n mapping(uint256 => uint64) private encryptedTokenIDs;\nmapping(address => mapping(address => mapping(uint64 => uint64))) internal allowances;\nmapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction transferFrom(\n        address from,\n        address to,\n        uint64 encryptedTokenID,\n        uint64 amount\n    ) public virtual returns (bool) {\n        address spender = msg.sender;\n        bool flag = transferFrom_priv(from, to, spender, encryptedTokenID, amount);\n        return transferFrom_callback(flag);\n    }\n\nfunction transferFrom_priv(\n        address from,\n        address to,\n        address spender,\n        uint64 encryptedTokenID,\n        uint64 amount\n    ) internal returns (bool) {\n        _transferHidden(from, to, spender, encryptedTokenID, amount);\n        return true;\n    }\n\nfunction _transferHidden(\n        address from,\n        address to,\n        address spender,\n        uint64 encryptedTokenID,\n        uint64 amount\n    ) internal virtual {\n        for (uint256 i = 0; i < _getNumberOfTokens(); i++) {\n            uint64 currentTokenID = encryptedTokenIDs[i];\n            emit TokenAccessed(currentTokenID);\n            _checkAndTransferBalances(from, to, spender, currentTokenID, encryptedTokenID, amount);\n        }\n        emit Transfer(from, to);\n    }\n\nfunction _checkAndTransferBalances(\n        address from,\n        address to,\n        address spender,\n        uint64 currentTokenID,\n        uint64 encryptedTokenID,\n        uint64 amount\n    ) internal {\n        bool isCorrectToken = encryptedTokenID == currentTokenID;\n        uint64 currentBalance = balances[from][currentTokenID];\n        uint64 currentAllowance = _allowance(from, spender, currentTokenID);\n        emit BalanceBeforeTransfer(currentTokenID, currentBalance, currentAllowance);\n\n        bool allowedTransfer = amount <= currentAllowance;\n        bool canTransfer = amount <= currentBalance;\n        bool isTransferable = canTransfer && allowedTransfer;\n\n        uint64 updatedAllowance = isTransferable?currentAllowance -amount : currentAllowance;\n        allowances[from][spender][currentTokenID] = updatedAllowance;\n\n        uint64 transferAmount = isCorrectToken? amount: 0;\n        uint64 transferValue = isTransferable? transferAmount:0;\n\n        emit TransferValue(currentTokenID, transferValue);\n\n        _updateBalances(from, to, currentTokenID, transferValue);\n    }\n\nfunction _updateBalances(address from, address to, uint64 currentTokenID, uint64 transferValue) internal {\n        uint64 newBalanceTo = balances[to][currentTokenID] + transferValue;\n        balances[to][currentTokenID] = newBalanceTo;\n\n        uint64 newBalanceFrom = balances[from][currentTokenID] - transferValue;\n        balances[from][currentTokenID] = newBalanceFrom;\n\n        emit BalanceAfterTransfer(\n            currentTokenID,\n            newBalanceTo,\n            newBalanceFrom,\n            allowances[from][msg.sender][currentTokenID]\n        );\n    }\n\nfunction _allowance(\n        address owner,\n        address spender,\n        uint64 encryptedTokenID\n    ) internal view virtual returns (uint64) {\n        return allowances[owner][spender][encryptedTokenID];\n    }\n\nfunction _getNumberOfTokens() internal pure returns (uint256) {\n        return 3; // Example with 3 tokens (extendable if needed)\n    }\n\nfunction transferFrom_callback(\n        bool flag\n    ) internal pure returns (bool) {\n        return flag;\n    }}"
        },
        {
            "target_contract_name": "EncryptedFunds",
            "target_func_name": "balanceOf",
            "original": " contract EncryptedFunds{\n mapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction balanceOf(address account, uint64 encryptedTokenID) public view virtual returns (uint64) {\n        // Return the balance of the specified account for the specified encrypted token ID\n        return balances[account][encryptedTokenID];\n    }}",
            "partition": " contract EncryptedFunds{\n mapping(address => mapping(uint64 => uint64)) internal balances;\nstruct TokenMetadata {\n        string name;\n        string symbol;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent Transfer(address indexed from, address indexed to);\nevent Approval(address indexed owner, address indexed spender);\nevent Mint(address indexed to, uint64 encryptedTokenID, uint64 amount);\nevent TotalSupplyUpdated(uint64 tokenID, uint64 totalSupply);\nevent TokenAccessed(uint64 tokenID);\nevent BalanceBeforeTransfer(uint64 tokenID, uint64 balance, uint64 allowance);\nevent TransferValue(uint64 tokenID, uint64 transferValue);\nevent BalanceAfterTransfer(uint64 tokenID, uint64 newBalanceTo, uint64 newBalanceFrom, uint64 updatedAllowance);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction balanceOf(address account, uint64 encryptedTokenID) public view virtual returns (uint64) {\n        require(msg.sender == account);\n        // Return the balance of the specified account for the specified encrypted token ID\n        uint64 amt = balanceOf_priv(account, encryptedTokenID);\n        return balanceOf_callback(amt);\n    }\n\nfunction balanceOf_priv(address account, uint64 encryptedTokenID) internal view returns (uint64) {\n        // Return the balance of the specified account for the specified encrypted token ID\n        return balances[account][encryptedTokenID];\n    }\n\nfunction balanceOf_callback(uint64 amt) internal pure returns (uint64) {\n        // Return the balance of the specified account for the specified encrypted token ID\n        return amt;\n    }}"
        }
    ],
    "Suffragium": [
        {
            "target_contract_name": "Suffragium",
            "target_func_name": "createVote",
            "original": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } \nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\n}",
            "partition": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } address private _owner;\nmapping(uint256 => Vote) private _votes;\nuint256 public numberOfVotes;\nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction createVote(uint256 endBlock, uint256 minQuorum, string calldata description) external onlyOwner {\n        createVote_priv(endBlock, minQuorum, description);\n    }\n\nfunction createVote_priv(uint256 endBlock, uint256 minQuorum, string calldata description) internal {\n        uint256 voteId = numberOfVotes;\n        _votes[voteId] = Vote(endBlock, minQuorum, 0, 0, 0, description, VoteState.Created);\n        numberOfVotes++;\n        emit VoteCreated(voteId);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}"
        },
        {
            "target_contract_name": "Suffragium",
            "target_func_name": "castVote",
            "original": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } \nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\n}",
            "partition": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } mapping(uint256 => Vote) private _votes;\nmapping(uint256 => mapping(bytes32 => bool)) private _castedVotes;\nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction castVote(\n        uint256 voteId,\n        bool support,\n        bytes32 voterId\n    ) external {\n        castVote_priv(voteId, support, voterId);\n    }\n\nfunction castVote_priv(\n        uint256 voteId,\n        bool support,\n        bytes32 voterId\n    ) internal {\n        // NOTE: If an attacker gains access to the email, they can generate a proof and submit it on-chain with a support value greater than 1, resulting in censorship of the legitimate voter.\n        if (_castedVotes[voteId][voterId]) revert AlreadyVoted();\n        _castedVotes[voteId][voterId] = true;\n\n        Vote storage vote = _getVote(voteId);\n        if (block.number > vote.endBlock) revert VoteClosed();\n\n        // Increment the vote count for this specific vote\n        vote.voteCount++;\n\n        // Update vote tallies if vote is valid\n        vote.encryptedResult = vote.encryptedResult + (support?1:0);\n       \n        emit VoteCasted(voteId);\n    }\n\nfunction _getVote(uint256 voteId) internal view returns (Vote storage) {\n        Vote storage vote = _votes[voteId];\n        if (vote.endBlock == 0) revert VoteDoesNotExist();\n        return vote;\n    }}"
        },
        {
            "target_contract_name": "Suffragium",
            "target_func_name": "getVote",
            "original": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } \nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\n}",
            "partition": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } mapping(uint256 => Vote) private _votes;\nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getVote(uint256 voteId) external view returns (Vote memory) {\n        Vote memory vote = getVote_priv(voteId);\n        return getVote_callback(vote);\n    }\n\nfunction getVote_callback(Vote memory vote) internal pure returns (Vote memory) {\n        return vote;\n    }\n\nfunction getVote_priv(uint256 voteId) internal view returns (Vote memory) {\n        return _getVote(voteId);\n    }\n\nfunction _getVote(uint256 voteId) internal view returns (Vote storage) {\n        Vote storage vote = _votes[voteId];\n        if (vote.endBlock == 0) revert VoteDoesNotExist();\n        return vote;\n    }}"
        },
        {
            "target_contract_name": "Suffragium",
            "target_func_name": "isVotePassed",
            "original": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } \nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\n}",
            "partition": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } mapping(uint256 => Vote) private _votes;\nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction isVotePassed(uint256 voteId) external view returns (bool) {\n       bool flag = isVotePassed_priv(voteId);\n       return isVotePassed_callback(flag);\n    }\n\nfunction isVotePassed_priv(uint256 voteId) internal view returns (bool) {\n        Vote storage vote = _getVote(voteId);\n        if (vote.state != VoteState.Revealed) return false;\n        if (vote.result == 0) return false;\n        return (vote.result * 10 ** 18) / vote.voteCount >= vote.minQuorum;\n    }\n\nfunction _getVote(uint256 voteId) internal view returns (Vote storage) {\n        Vote storage vote = _votes[voteId];\n        if (vote.endBlock == 0) revert VoteDoesNotExist();\n        return vote;\n    }\n\nfunction isVotePassed_callback(bool flag) internal pure returns (bool) {\n        return flag;\n    }}"
        },
        {
            "target_contract_name": "Suffragium",
            "target_func_name": "requestRevealVote",
            "original": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } \nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\n}",
            "partition": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } mapping(uint256 => Vote) private _votes;\nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction requestRevealVote(uint256 voteId) external {\n        requestRevealVote_priv(voteId);\n    }\n\nfunction requestRevealVote_priv(uint256 voteId) internal {\n        Vote storage vote = _getVote(voteId);\n        if (block.number <= vote.endBlock) revert VoteNotClosed();\n\n        // Request decryption of vote results through the Gateway\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = vote.encryptedResult;\n        vote.state = VoteState.RequestedToReveal;\n\n        emit VoteRevealRequested(voteId);\n    }\n\nfunction _getVote(uint256 voteId) internal view returns (Vote storage) {\n        Vote storage vote = _votes[voteId];\n        if (vote.endBlock == 0) revert VoteDoesNotExist();\n        return vote;\n    }}"
        },
        {
            "target_contract_name": "Suffragium",
            "target_func_name": "revealVote",
            "original": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } \nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\n}",
            "partition": " contract Suffragium{\nenum VoteState {\n        NotCreated,\n        Created,\n        RequestedToReveal,\n        Revealed\n    } mapping(uint256 => Vote) private _votes;\nstruct Vote {\n        uint256 endBlock;\n        uint256 minQuorum;\n        uint64 encryptedResult;\n        uint256 result;\n        uint256 voteCount;\n        string description;\n        VoteState state;\n    }\nevent MinQuorumSet(uint256 minQuorum);\nevent VoteCasted(uint256 indexed voteId);\nevent VoteCreated(uint256 indexed voteId);\nevent VoteRevealRequested(uint256 indexed voteId);\nevent VoteRevealed(uint256 indexed voteId);\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nerror DkimSignatureVerificationFailed();\nerror InvalidEmailPublicKeyHash();\nerror InvalidFromDomainHash();\nerror AlreadyVoted();\nerror VoteDoesNotExist();\nerror VoteNotClosed();\nerror VoteClosed();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction revealVote(uint256 voteId, uint256 result) external {\n        // Update vote with decrypted results\n        revealVote_priv(voteId, result);\n    }\n\nfunction revealVote_priv(uint256 voteId, uint256 result) internal {\n        // Update vote with decrypted results\n        Vote storage vote = _getVote(voteId);\n        vote.state = VoteState.Revealed;\n        vote.result = result;\n        emit VoteRevealed(voteId);\n    }\n\nfunction _getVote(uint256 voteId) internal view returns (Vote storage) {\n        Vote storage vote = _votes[voteId];\n        if (vote.endBlock == 0) revert VoteDoesNotExist();\n        return vote;\n    }}"
        }
    ],
    "BlindAuction": [
        {
            "target_contract_name": "BlindAuction",
            "target_func_name": "bid",
            "original": " contract BlindAuction{\n uint64 private highestBid;\nmapping(address account => uint64 bidAmount) private bids;\nuint256 public endTime;\nbool public manuallyStopped = false;\nEncryptedERC20 public tokenContract;\nuint256 public bidCounter;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction bid(uint64 value) external onlyBeforeEnd {\n        uint64 existingBid = bids[msg.sender];\n        uint64 sentBalance;\n        if (existingBid>0) {\n            uint64 balanceBefore = tokenContract.balanceOf(address(this));\n            bool isHigher = existingBid < value;\n            uint64 toTransfer = value - existingBid;\n\n            // Transfer only if bid is higher, also to avoid overflow from previous line\n            uint64 amount = 0;\n            if (isHigher){\n                amount = toTransfer;\n            }\n            tokenContract.transferFrom(msg.sender, address(this), amount);\n\n            uint64 balanceAfter = tokenContract.balanceOf(address(this));\n            sentBalance = balanceAfter - balanceBefore;\n            uint64 newBid = existingBid + sentBalance;\n            bids[msg.sender] = newBid;\n        } else {\n            bidCounter++;\n            uint64 balanceBefore = tokenContract.balanceOf(address(this));\n            tokenContract.transferFrom(msg.sender, address(this), value);\n            uint64 balanceAfter = tokenContract.balanceOf(address(this));\n            sentBalance = balanceAfter - balanceBefore;\n            bids[msg.sender] = sentBalance;\n        }\n        uint64 currentBid = bids[msg.sender];\n\n        if (highestBid == 0) {\n            highestBid = currentBid;\n        } else {\n            bool isNewWinner = highestBid < currentBid;\n            if (isNewWinner){\n                highestBid = currentBid;\n            }\n        }\n    }\n\nmodifier onlyBeforeEnd() {\n        if (block.timestamp >= endTime || manuallyStopped == true) revert TooLate(endTime);\n        _;\n    }}",
            "partition": " contract BlindAuction{\n uint256 public endTime;\nbool public manuallyStopped = false;\nuint256 public bidCounter;\nuint64 private highestBid;\nmapping(address account => uint64 bidAmount) private bids;\nEncryptedERC20 public tokenContract;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction bid(uint64 value) external onlyBeforeEnd {\n       bool enable_bidCounter_increase = bid_priv(msg.sender, value);\n       bid_callback(enable_bidCounter_increase);\n    }\n\nmodifier onlyBeforeEnd() {\n        if (block.timestamp >= endTime || manuallyStopped == true) revert TooLate(endTime);\n        _;\n    }\n\nfunction bid_callback(bool enable_bidCounter_increase) internal {\n        if (enable_bidCounter_increase) {\n            bidCounter++;\n        }\n    }\n\nfunction bid_priv(address sender, uint64 value) internal returns (bool) {\n        bool enable_bidCounter_increase = false;\n        uint64 existingBid = bids[sender];\n        uint64 sentBalance;\n        if (existingBid>0) {\n            uint64 balanceBefore = tokenContract.balanceOf(address(this));\n            bool isHigher = existingBid < value;\n            uint64 toTransfer = value - existingBid;\n\n            // Transfer only if bid is higher, also to avoid overflow from previous line\n            uint64 amount = 0;\n            if (isHigher){\n                amount = toTransfer;\n            }\n            tokenContract.transferFrom(sender, address(this), amount);\n\n            uint64 balanceAfter = tokenContract.balanceOf(address(this));\n            sentBalance = balanceAfter - balanceBefore;\n            uint64 newBid = existingBid + sentBalance;\n            bids[sender] = newBid;\n        } else {\n            enable_bidCounter_increase = true;\n            uint64 balanceBefore = tokenContract.balanceOf(address(this));\n            tokenContract.transferFrom(sender, address(this), value);\n            uint64 balanceAfter = tokenContract.balanceOf(address(this));\n            sentBalance = balanceAfter - balanceBefore;\n            bids[sender] = sentBalance;\n        }\n        uint64 currentBid = bids[sender];\n\n        if (highestBid == 0) {\n            highestBid = currentBid;\n        } else {\n            bool isNewWinner = highestBid < currentBid;\n            if (isNewWinner){\n                highestBid = currentBid;\n            }\n        }\n        return enable_bidCounter_increase;\n    }}"
        },
        {
            "target_contract_name": "BlindAuction",
            "target_func_name": "getBid",
            "original": " contract BlindAuction{\n mapping(address account => uint64 bidAmount) private bids;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction getBid(address account) external view returns (uint64) {\n        return bids[account];\n    }}",
            "partition": " contract BlindAuction{\n mapping(address account => uint64 bidAmount) private bids;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction getBid(address account) external returns (uint64) {\n        assert(msg.sender == account);\n        uint64 amt = getBid_priv(msg.sender);\n        return getBid_callback(amt);\n    }\n\nfunction getBid_priv(address account) internal returns (uint64) {\n        uint64 amt = bids[account];\n        return amt;\n    }\n\nfunction getBid_callback(uint64 amt) internal returns (uint64) {\n        return amt;\n    }}"
        },
        {
            "target_contract_name": "BlindAuction",
            "target_func_name": "claim",
            "original": " contract BlindAuction{\n bool private objectClaimed;\nuint64 private highestBid;\nmapping(address account => uint64 bidAmount) private bids;\nuint256 public endTime;\nbool public manuallyStopped = false;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction claim() public onlyAfterEnd {\n        require(!objectClaimed);\n        uint64 bidValue = bids[msg.sender];\n        if (bidValue >= highestBid){\n            objectClaimed = true;\n            bids[msg.sender] = 0;\n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract BlindAuction{\n uint256 public endTime;\nbool public manuallyStopped = false;\nuint64 private highestBid;\nmapping(address account => uint64 bidAmount) private bids;\nbool private objectClaimed;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction claim() public onlyAfterEnd {\n        require(!objectClaimed);\n        bool enable_claim = claim_priv();\n        claim_callback(enable_claim);\n    }\n\nfunction claim_priv() internal returns (bool){\n        bool enable_claim = false;\n        uint64 bidValue = bids[msg.sender];\n        if (bidValue >= highestBid){\n            enable_claim = true;\n            bids[msg.sender] = 0;\n        }\n        return enable_claim;\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }\n\nfunction claim_callback(bool enable_claim) internal {\n        if (enable_claim){\n            objectClaimed = true;\n        }\n    }}"
        },
        {
            "target_contract_name": "BlindAuction",
            "target_func_name": "auctionEnd",
            "original": " contract BlindAuction{\n address public beneficiary;\nbool public tokenTransferred;\nuint64 private highestBid;\nuint256 public endTime;\nbool public manuallyStopped = false;\nEncryptedERC20 public tokenContract;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction auctionEnd() public onlyAfterEnd {\n        require(!tokenTransferred);\n        tokenTransferred = true;\n        tokenContract.transfer(beneficiary, highestBid);\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract BlindAuction{\n uint256 public endTime;\nbool public manuallyStopped = false;\nuint64 private highestBid;\naddress public beneficiary;\nEncryptedERC20 public tokenContract;\nbool public tokenTransferred;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction auctionEnd() public onlyAfterEnd {\n        require(!tokenTransferred);\n        auctionEnd_priv();\n        auctionEnd_callback();\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }\n\nfunction auctionEnd_priv() internal {\n        tokenContract.transfer(beneficiary, highestBid);\n    }\n\nfunction auctionEnd_callback() internal {\n        tokenTransferred = true;\n    }}"
        },
        {
            "target_contract_name": "BlindAuction",
            "target_func_name": "withdraw",
            "original": " contract BlindAuction{\n uint64 private highestBid;\nmapping(address account => uint64 bidAmount) private bids;\nuint256 public endTime;\nbool public manuallyStopped = false;\nEncryptedERC20 public tokenContract;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction withdraw() public onlyAfterEnd {\n        uint64 bidValue = bids[msg.sender];\n        if (bidValue < highestBid){\n            tokenContract.transfer(msg.sender, bidValue);    \n            bids[msg.sender] = 0;\n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract BlindAuction{\n uint256 public endTime;\nbool public manuallyStopped = false;\nuint64 private highestBid;\nmapping(address account => uint64 bidAmount) private bids;\nEncryptedERC20 public tokenContract;\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nerror TooEarly(uint256 time);\nerror TooLate(uint256 time);\nfunction withdraw() public onlyAfterEnd {\n        withdraw_priv(msg.sender);\n    }\n\nfunction withdraw_priv(address sender) internal {\n        uint64 bidValue = bids[sender];\n        if (bidValue < highestBid){\n            tokenContract.transfer(sender, bidValue);  \n            bids[msg.sender] = 0;  \n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp < endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}"
        }
    ],
    "ConfidentialIdentityRegistry": [
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "addRegistrar",
            "original": " contract ConfidentialIdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addRegistrar(address wallet, uint registrarId) public onlyOwner {\n        require(registrarId > 0, \"registrarId needs to be > 0\");\n        registrars[wallet] = registrarId;\n        emit NewRegistrar(wallet, registrarId);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addRegistrar(address wallet, uint registrarId) public onlyOwner {\n       addRegistrar_priv(wallet,registrarId);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction addRegistrar_priv(address wallet, uint registrarId) internal {\n        require(registrarId > 0, \"registrarId needs to be > 0\");\n        registrars[wallet] = registrarId;\n        emit NewRegistrar(wallet, registrarId);\n    }}"
        },
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "removeRegistrar",
            "original": " contract ConfidentialIdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeRegistrar(address wallet) public onlyOwner {\n        require(registrars[wallet] > 0, \"wallet is not registrar\");\n        registrars[wallet] = 0;\n        emit RemoveRegistrar(wallet);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeRegistrar(address wallet) public onlyOwner {\n        removeRegistrar_priv(wallet);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction removeRegistrar_priv(address wallet) internal {\n        require(registrars[wallet] > 0, \"wallet is not registrar\");\n        registrars[wallet] = 0;\n        emit RemoveRegistrar(wallet);\n    }}"
        },
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "addDid",
            "original": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addDid(address wallet) public onlyRegistrar {\n        require(\n            identities[wallet].registrarId == 0,\n            \"This wallet is already registered\"\n        );\n        Identity storage newIdentity = identities[wallet];\n        newIdentity.registrarId = registrars[msg.sender];\n        emit NewDid(wallet);\n    }\n\nmodifier onlyRegistrar() {\n        require(registrars[msg.sender] > 0, \"You're not a registrar\");\n        _;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addDid(address wallet) public onlyRegistrar {\n        uint registrarId = registrars[msg.sender];\n        addDid_priv(wallet, registrarId);\n    }\n\nfunction addDid_priv(address wallet, uint registrarId) internal {\n        require(\n            identities[wallet].registrarId == 0,\n            \"This wallet is already registered\"\n        );\n        Identity storage newIdentity = identities[wallet];\n        newIdentity.registrarId = registrarId;\n        emit NewDid(wallet);\n    }\n\nmodifier onlyRegistrar() {\n        require(registrars[msg.sender] > 0, \"You're not a registrar\");\n        _;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "removeDid",
            "original": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeDid(\n        address wallet\n    ) public onlyExistingWallet(wallet) onlyRegistrarOf(wallet) {\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            identities[wallet].identifiers[identifierList_[i]] = 0;\n        }\n        delete identities[wallet];\n        emit RemoveDid(wallet);\n    }\n\nmodifier onlyRegistrarOf(address wallet) {\n        uint registrarId = registrars[msg.sender];\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        _;\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeDid(\n        address wallet\n    ) public {\n        uint registrarId = registrars[msg.sender];\n        removeDid_priv(wallet, registrarId);\n    }\n\nfunction removeDid_priv(\n        address wallet, uint registrarId\n    ) internal onlyExistingWallet(wallet) {\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            identities[wallet].identifiers[identifierList_[i]] = 0;\n        }\n        delete identities[wallet];\n        emit RemoveDid(wallet);\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "setIdentifier",
            "original": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nuint constant MAX_IDENTIFIERS_LENGTH = 20;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction setIdentifier(\n        address wallet,\n        string memory identifier,\n        uint64 value\n    ) external onlyExistingWallet(wallet) onlyRegistrarOf(wallet) {\n        identities[wallet].identifiers[identifier] = value;\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) return;\n        }\n        require(\n            identifierLength + 1 <= MAX_IDENTIFIERS_LENGTH,\n            \"Too many identifiers\"\n        );\n        identities[wallet].identifierList.push(identifier);\n    }\n\nmodifier onlyRegistrarOf(address wallet) {\n        uint registrarId = registrars[msg.sender];\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        _;\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nuint constant MAX_IDENTIFIERS_LENGTH = 20;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction setIdentifier(\n        address wallet,\n        string memory identifier,\n        uint64 value\n    ) external {\n        uint registrarId = registrars[msg.sender];\n\n        setIdentifier_priv(wallet, identifier, value, registrarId);\n    }\n\nfunction setIdentifier_priv(\n        address wallet,\n        string memory identifier,\n        uint64 value,\n        uint registrarId\n    ) internal onlyExistingWallet(wallet) {\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        identities[wallet].identifiers[identifier] = value;\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) return;\n        }\n        require(\n            identifierLength + 1 <= MAX_IDENTIFIERS_LENGTH,\n            \"Too many identifiers\"\n        );\n        identities[wallet].identifierList.push(identifier);\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "removeIdentifier",
            "original": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeIdentifier(\n        address wallet,\n        string memory identifier\n    ) external onlyExistingWallet(wallet) onlyRegistrarOf(wallet) {\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) {\n                identities[wallet].identifierList[i] = identities[wallet]\n                    .identifierList[identifierLength - 1];\n                identities[wallet].identifierList.pop();\n                return;\n            }\n        }\n        require(false, \"Identifier not found\");\n    }\n\nmodifier onlyRegistrarOf(address wallet) {\n        uint registrarId = registrars[msg.sender];\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        _;\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeIdentifier(\n        address wallet,\n        string memory identifier\n    ) external {\n        uint registrarId = registrars[msg.sender];\n\n        removeIdentifier_priv(wallet, identifier, registrarId);\n    }\n\nfunction removeIdentifier_priv(\n        address wallet,\n        string memory identifier,\n        uint registrarId\n    ) internal onlyExistingWallet(wallet) {\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) {\n                identities[wallet].identifierList[i] = identities[wallet]\n                    .identifierList[identifierLength - 1];\n                identities[wallet].identifierList.pop();\n                return;\n            }\n        }\n        require(false, \"Identifier not found\");\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "getRegistrar",
            "original": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getRegistrar(address wallet) public view returns (uint) {\n        return identities[wallet].registrarId;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getRegistrar(address wallet) public view returns (uint) {\n        uint registrarId = getRegistrar_priv(wallet);\n        return getRegistrar_callback(registrarId);\n    }\n\nfunction getRegistrar_priv(address wallet) public view returns (uint) {\n        return identities[wallet].registrarId;\n    }\n\nfunction getRegistrar_callback(uint registrarId) public view returns (uint) {\n        return registrarId;\n    }}"
        },
        {
            "target_contract_name": "ConfidentialIdentityRegistry",
            "target_func_name": "getIdentifier",
            "original": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => mapping(address => mapping(string => bool))) permissions;\naddress private _owner;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getIdentifier(\n        address wallet,\n        string calldata identifier\n    )\n        public\n        onlyExistingWallet(wallet)\n        onlyAllowed(wallet, identifier)\n        returns (uint64)\n    {\n        return\n            identities[wallet].identifiers[identifier];\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }\n\nmodifier onlyAllowed(address wallet, string memory identifier) {\n        require(\n            owner() == msg.sender ||\n                permissions[wallet][msg.sender][identifier],\n            \"User didn't give you permission to access this identifier.\"\n        );\n        _;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}",
            "partition": " contract ConfidentialIdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => mapping(address => mapping(string => bool))) permissions;\naddress private _owner;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getIdentifier(\n        address wallet,\n        string calldata identifier\n    )\n        public\n        onlyAllowed(wallet, identifier)\n        returns (uint64)\n    {\n        uint64 id = getIdentifier_priv(wallet, identifier);\n        return getIdentifier_callback(id);\n    }\n\nmodifier onlyAllowed(address wallet, string memory identifier) {\n        require(\n            owner() == msg.sender ||\n                permissions[wallet][msg.sender][identifier],\n            \"User didn't give you permission to access this identifier.\"\n        );\n        _;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction getIdentifier_priv(\n        address wallet,\n        string calldata identifier\n    )\n        public\n        onlyExistingWallet(wallet)\n        returns (uint64)\n    {\n        return\n            identities[wallet].identifiers[identifier];\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }\n\nfunction getIdentifier_callback(uint64 id) public view returns (uint64) {\n        return id;\n    }}"
        }
    ],
    "GovernorZama": [
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "queue",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } uint public proposalCount;\nmapping(uint => Proposal) public proposals;\nTimelockInterface public timelock;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction queue(uint proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\nfunction _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\nfunction state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } TimelockInterface public timelock;\nuint public proposalCount;\nmapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction queue(uint proposalId) public {\n        queue_priv(proposalId);\n    }\n\nfunction queue_priv(uint proposalId) internal {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\nfunction _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\nfunction state(uint proposalId) public returns (ProposalState) {\n        ProposalState pstate = state_priv(proposalId);\n        return state_callback(pstate);\n    }\n\nfunction state_callback(ProposalState pstate) public view returns (ProposalState) {\n        return pstate;\n    }\n\nfunction state_priv(uint proposalId) internal returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "execute",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } uint public proposalCount;\nmapping(uint => Proposal) public proposals;\nTimelockInterface public timelock;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction execute(uint proposalId) public payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\nfunction state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } TimelockInterface public timelock;\nuint public proposalCount;\nmapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction execute(uint proposalId) public payable {\n        execute_priv(proposalId);\n    }\n\nfunction execute_priv(uint proposalId) internal {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\nfunction state(uint proposalId) public returns (ProposalState) {\n        ProposalState pstate = state_priv(proposalId);\n        return state_callback(pstate);\n    }\n\nfunction state_callback(ProposalState pstate) public view returns (ProposalState) {\n        return pstate;\n    }\n\nfunction state_priv(uint proposalId) internal returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "getActions",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } mapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction getActions(\n        uint proposalId\n    )\n        public\n        view\n        returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } mapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction getActions(\n        uint proposalId\n    )\n        public\n        view\n        returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)\n    {\n        (targets, values, signatures, calldatas) = getActions_priv(proposalId);\n        return getActions_callback(targets, values, signatures, calldatas);\n    }\n\nfunction getActions_priv(\n        uint proposalId\n    )\n        public\n        view\n        returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\nfunction getActions_callback(\n        address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas\n    )\n        internal pure\n        returns (address[] memory , uint[] memory , string[] memory, bytes[] memory )\n    {\n       \n        return (targets, values, signatures, calldatas);\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "getReceipt",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } mapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } mapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n        Receipt memory receipt = getReceipt_priv(proposalId, voter);\n        return getReceipt_callback(receipt);\n    }\n\nfunction getReceipt_callback(Receipt memory receipt) public view returns (Receipt memory) {\n        return receipt;\n    }\n\nfunction getReceipt_priv(uint proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "state",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } uint public proposalCount;\nmapping(uint => Proposal) public proposals;\nTimelockInterface public timelock;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } TimelockInterface public timelock;\nuint public proposalCount;\nmapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction state(uint proposalId) public returns (ProposalState) {\n        ProposalState pstate = state_priv(proposalId);\n        return state_callback(pstate);\n    }\n\nfunction state_callback(ProposalState pstate) public view returns (ProposalState) {\n        return pstate;\n    }\n\nfunction state_priv(uint proposalId) internal returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "castVote",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } CompInterface public comp;\nuint public proposalCount;\nmapping(uint => Proposal) public proposals;\nTimelockInterface public timelock;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction castVote(uint proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\nfunction _castVote(address voter, uint proposalId, bool support) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint64 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        proposal.forVotes = support? proposal.forVotes + votes: proposal.forVotes;\n        proposal.againstVotes = support? proposal.againstVotes: proposal.againstVotes + votes;\n \n        receipt.hasVoted = true;\n        receipt.votes = votes;\n\n        // `support` and `votes` are encrypted values, no need to include them in the event.\n        // emit VoteCast(voter, proposalId, support, votes);\n        emit VoteCast(voter, proposalId);\n    }\n\nfunction state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } TimelockInterface public timelock;\nCompInterface public comp;\nuint public proposalCount;\nmapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction castVote(uint proposalId, bool support) public {\n        castVote_priv(msg.sender, proposalId, support);\n    }\n\nfunction castVote_priv(address sender, uint proposalId, bool support) internal {\n        _castVote(sender, proposalId, support);\n    }\n\nfunction _castVote(address voter, uint proposalId, bool support) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint64 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        proposal.forVotes = support? proposal.forVotes + votes: proposal.forVotes;\n        proposal.againstVotes = support? proposal.againstVotes: proposal.againstVotes + votes;\n \n        receipt.hasVoted = true;\n        receipt.votes = votes;\n\n        // `support` and `votes` are encrypted values, no need to include them in the event.\n        // emit VoteCast(voter, proposalId, support, votes);\n        emit VoteCast(voter, proposalId);\n    }\n\nfunction state(uint proposalId) public returns (ProposalState) {\n        ProposalState pstate = state_priv(proposalId);\n        return state_callback(pstate);\n    }\n\nfunction state_callback(ProposalState pstate) public view returns (ProposalState) {\n        return pstate;\n    }\n\nfunction state_priv(uint proposalId) internal returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "castVoteBySig",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } mapping(uint => Proposal) public proposals;\nbytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\nCompInterface public comp;\nbytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\nTimelockInterface public timelock;\nstring public constant name = \"Compound Governor Zama\";\nuint public proposalCount;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\nfunction getChainId() internal view returns (uint) {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\nfunction _castVote(address voter, uint proposalId, bool support) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint64 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        proposal.forVotes = support? proposal.forVotes + votes: proposal.forVotes;\n        proposal.againstVotes = support? proposal.againstVotes: proposal.againstVotes + votes;\n \n        receipt.hasVoted = true;\n        receipt.votes = votes;\n\n        // `support` and `votes` are encrypted values, no need to include them in the event.\n        // emit VoteCast(voter, proposalId, support, votes);\n        emit VoteCast(voter, proposalId);\n    }\n\nfunction state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } CompInterface public comp;\nbytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\nstring public constant name = \"Compound Governor Zama\";\nuint public proposalCount;\nbytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\nTimelockInterface public timelock;\nmapping(uint => Proposal) public proposals;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\nfunction getChainId() internal view returns (uint) {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\nfunction _castVote(address voter, uint proposalId, bool support) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint64 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        proposal.forVotes = support? proposal.forVotes + votes: proposal.forVotes;\n        proposal.againstVotes = support? proposal.againstVotes: proposal.againstVotes + votes;\n \n        receipt.hasVoted = true;\n        receipt.votes = votes;\n\n        // `support` and `votes` are encrypted values, no need to include them in the event.\n        // emit VoteCast(voter, proposalId, support, votes);\n        emit VoteCast(voter, proposalId);\n    }\n\nfunction state(uint proposalId) public returns (ProposalState) {\n        ProposalState pstate = state_priv(proposalId);\n        return state_callback(pstate);\n    }\n\nfunction state_callback(ProposalState pstate) public view returns (ProposalState) {\n        return pstate;\n    }\n\nfunction state_priv(uint proposalId) internal returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        }\n        // We can't have this for privacy reasons; otherwise, users could spam-call the `state` view function and deduce individual votes.\n        // We must then only reveal the defeat/success of a proposal after the time limit has been reached.\n        // else if (\n        //     proposal.forVotes <= proposal.againstVotes ||\n        //     proposal.forVotes < ()\n        // ) {\n        //     return ProposalState.Defeated;\n        // }\n        else if (proposal.eta == 0) {\n            if (isDefeated(proposal)) {\n                return ProposalState.Defeated;\n            } else {\n                return ProposalState.Succeeded;\n            }\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\nfunction isDefeated(Proposal storage proposal) private view returns (bool) {\n        // revert();\n        bool defeated = proposal.forVotes <= proposal.againstVotes;\n        bool reachedQuorum = proposal.forVotes < uint64(quorumVotes());\n\n        return reachedQuorum || defeated;\n    }\n\nfunction quorumVotes() public pure returns (uint) {\n        return 10000;\n        // return 400000e18;\n    }\n\nfunction add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "__acceptAdmin",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } address public guardian;\nTimelockInterface public timelock;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction __acceptAdmin() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } TimelockInterface public timelock;\naddress public guardian;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction __acceptAdmin() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        __acceptAdmin_priv();\n    }\n\nfunction __acceptAdmin_priv() internal {\n        timelock.acceptAdmin();\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "__queueSetTimelockPendingAdmin",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } address public guardian;\nTimelockInterface public timelock;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } TimelockInterface public timelock;\naddress public guardian;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        __queueSetTimelockPendingAdmin_priv(newPendingAdmin, eta);\n    }\n\nfunction __queueSetTimelockPendingAdmin_priv(address newPendingAdmin, uint eta) internal {\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }}"
        },
        {
            "target_contract_name": "GovernorZama",
            "target_func_name": "__executeSetTimelockPendingAdmin",
            "original": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } address public guardian;\nTimelockInterface public timelock;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }}",
            "partition": " contract GovernorZama{\nenum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    } TimelockInterface public timelock;\naddress public guardian;\nstruct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint64 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint64 againstVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\nstruct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n        /// @notice The number of votes the voter had, which were cast\n        uint64 votes;\n    }\nevent ProposalCreated(\n        uint id,\n        address proposer,\n        address[] targets,\n        uint[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint startBlock,\n        uint endBlock,\n        string description\n    );\nevent VoteCast(address voter, uint proposalId);\nevent ProposalCanceled(uint id);\nevent ProposalQueued(uint id, uint eta);\nevent ProposalExecuted(uint id);\n\nfunction __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        __executeSetTimelockPendingAdmin_priv(newPendingAdmin, eta);\n    }\n\nfunction __executeSetTimelockPendingAdmin_priv(address newPendingAdmin, uint eta) internal {\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }}"
        }
    ],
    "CipherBomb": [
        {
            "target_contract_name": "CipherBomb",
            "target_func_name": "start",
            "original": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nuint8 public numberOfPlayers;\nmapping(address => bool) roles;\nbool public gameRoleDealNeeded;\nuint8 public remainingWires;\nuint public constant MIN_PLAYERS = 4;\nbool public gameRunning;\naddress[6] public players;\naddress public turnCurrentPlayer;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction start() public onlyGameOpen {\n        require(numberOfPlayers >= MIN_PLAYERS, \"Not enough player to start\");\n        bool roleDistributed = giveRoles();\n        if (roleDistributed) {\n            remainingWires = numberOfPlayers;\n            turnCurrentPlayer = players[0];\n            gameOpen = false;\n            gameRunning = true;\n            emit GameStart();\n        }\n    }\n\nmodifier onlyGameOpen() {\n        require(gameOpen && !gameRunning, \"The game is not open\");\n        _;\n    }\n\nfunction giveRoles() internal onlyRoleDealNeeded returns (bool) {\n        uint8 badGuys = 2;\n        uint8[] memory positions = dealCards(badGuys, numberOfPlayers == 4 ? numberOfPlayers : numberOfPlayers - 1);\n        if (numberOfPlayers > 4) {\n            bool isCorrect = positions[0] != positions[1];\n            if (!isCorrect) {\n                return false;\n            }\n        }\n        for (uint8 i; i < numberOfPlayers; i++) {\n            bool role = positions[0] != i && positions[1] != i; // If equal, role is bad guy (so = 0)\n            roles[players[i]] = role; // 1 = Nice guy / 0 = Bad guy\n        }\n        gameRoleDealNeeded = false;\n        return true;\n    }\n\nfunction dealCards(uint8 positionsToGenerate, uint8 range) internal returns (uint8[] memory) {\n        require(range < 7);\n        uint8[] memory positions = new uint8[](positionsToGenerate);\n\n        // euint32 random32 = TFHE.randEuint32();\n        uint32 random32 = 0xfe; // we fix a constant value for evaluation, which cannot be used for product version.\n\n        uint8 rangeBits = getRangeBits(range); // number of bits needed at most\n\n        for (uint8 i; i < positionsToGenerate; i++) {\n            uint8 random8 = uint8(random32 >> (i * rangeBits));\n            uint256 mask = 2 ** rangeBits - 1;\n            random8 =  uint8(random8 & mask);\n            positions[i] = generateNumber(random8, range);\n        }\n        return positions;\n    }\n\nfunction generateNumber(uint8 random8, uint8 range) internal returns (uint8) {\n        // currently do not support random number generation \n        // return TFHE.cmux(TFHE.lt(random8, range), random8, TFHE.sub(random8, range));\n        return random8;\n    }\n\nfunction getRangeBits(uint8 range) internal pure returns (uint8) {\n        uint8 rangeBits = 1;\n        if (range > 3) {\n            rangeBits = 3;\n        } else if (range > 1) {\n            rangeBits = 2;\n        }\n        return rangeBits;\n    }\n\nmodifier onlyRoleDealNeeded() {\n        require(gameRoleDealNeeded, \"No need to deal cards\");\n        _;\n    }}",
            "partition": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } uint8 public numberOfPlayers;\naddress public turnCurrentPlayer;\nuint8 public remainingWires;\nbool public gameRunning;\nuint public constant MIN_PLAYERS = 4;\nbool public gameOpen;\nbool public gameRoleDealNeeded;\naddress[6] public players;\nmapping(address => bool) roles;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction start() public onlyGameOpen {\n        require(numberOfPlayers >= MIN_PLAYERS, \"Not enough player to start\");\n        require(gameRoleDealNeeded, \"No need to deal cards\");\n        bool flag = start_priv();\n        start_callback(flag);\n    }\n\nmodifier onlyGameOpen() {\n        require(gameOpen && !gameRunning, \"The game is not open\");\n        _;\n    }\n\nfunction start_priv() internal returns (bool) {\n        bool flag = giveRoles_priv();\n        return flag;\n    }\n\nfunction giveRoles_priv() internal returns (bool) {\n        uint8 badGuys = 2;\n        uint8[] memory positions = dealCards(badGuys, numberOfPlayers == 4 ? numberOfPlayers : numberOfPlayers - 1);\n        if (numberOfPlayers > 4) {\n            bool isCorrect = positions[0] != positions[1];\n            if (!isCorrect) {\n                return false;\n            }\n        }\n        for (uint8 i; i < numberOfPlayers; i++) {\n            bool role = positions[0] != i && positions[1] != i; // If equal, role is bad guy (so = 0)\n            roles[players[i]] = role; // 1 = Nice guy / 0 = Bad guy\n        }\n        return true;\n    }\n\nfunction dealCards(uint8 positionsToGenerate, uint8 range) internal returns (uint8[] memory) {\n        require(range < 7);\n        uint8[] memory positions = new uint8[](positionsToGenerate);\n\n        // euint32 random32 = TFHE.randEuint32();\n        uint32 random32 = 0xfe; // we fix a constant value for evaluation, which cannot be used for product version.\n\n        uint8 rangeBits = getRangeBits(range); // number of bits needed at most\n\n        for (uint8 i; i < positionsToGenerate; i++) {\n            uint8 random8 = uint8(random32 >> (i * rangeBits));\n            uint256 mask = 2 ** rangeBits - 1;\n            random8 =  uint8(random8 & mask);\n            positions[i] = generateNumber(random8, range);\n        }\n        return positions;\n    }\n\nfunction getRangeBits(uint8 range) internal pure returns (uint8) {\n        uint8 rangeBits = 1;\n        if (range > 3) {\n            rangeBits = 3;\n        } else if (range > 1) {\n            rangeBits = 2;\n        }\n        return rangeBits;\n    }\n\nfunction generateNumber(uint8 random8, uint8 range) internal returns (uint8) {\n        // currently do not support random number generation \n        // return TFHE.cmux(TFHE.lt(random8, range), random8, TFHE.sub(random8, range));\n        return random8;\n    }\n\nfunction start_callback(bool flag) internal {\n        bool roleDistributed = giveRoles_callback(flag);\n        if (roleDistributed) {\n            remainingWires = numberOfPlayers;\n            turnCurrentPlayer = players[0];\n            gameOpen = false;\n            gameRunning = true;\n            emit GameStart();\n        }\n    }\n\nfunction giveRoles_callback(bool flag) internal returns (bool) {\n        if (flag){\n            gameRoleDealNeeded = false;\n        }\n        return flag;\n    }}"
        },
        {
            "target_contract_name": "CipherBomb",
            "target_func_name": "deal",
            "original": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nuint8 public numberOfPlayers;\nbool public turnDealNeeded;\nuint8 bombPosition;\nuint8 public remainingWires;\nuint8[6] wirePositions;\nbool public gameRunning;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction deal() public onlyGameRunning onlyTurnDealNeeded {\n        require(turnDealNeeded, \"There is no need to deal cards\");\n        uint8[] memory positions = dealCards(uint8(remainingWires + 1), numberOfPlayers);\n        for (uint i; i < positions.length; i++) {\n            if (i == positions.length - 1) {\n                bombPosition = positions[i];\n            } else {\n                wirePositions[i] = positions[i];\n            }\n        }\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nfunction dealCards(uint8 positionsToGenerate, uint8 range) internal returns (uint8[] memory) {\n        require(range < 7);\n        uint8[] memory positions = new uint8[](positionsToGenerate);\n\n        // euint32 random32 = TFHE.randEuint32();\n        uint32 random32 = 0xfe; // we fix a constant value for evaluation, which cannot be used for product version.\n\n        uint8 rangeBits = getRangeBits(range); // number of bits needed at most\n\n        for (uint8 i; i < positionsToGenerate; i++) {\n            uint8 random8 = uint8(random32 >> (i * rangeBits));\n            uint256 mask = 2 ** rangeBits - 1;\n            random8 =  uint8(random8 & mask);\n            positions[i] = generateNumber(random8, range);\n        }\n        return positions;\n    }\n\nfunction generateNumber(uint8 random8, uint8 range) internal returns (uint8) {\n        // currently do not support random number generation \n        // return TFHE.cmux(TFHE.lt(random8, range), random8, TFHE.sub(random8, range));\n        return random8;\n    }\n\nfunction getRangeBits(uint8 range) internal pure returns (uint8) {\n        uint8 rangeBits = 1;\n        if (range > 3) {\n            rangeBits = 3;\n        } else if (range > 1) {\n            rangeBits = 2;\n        }\n        return rangeBits;\n    }\n\nmodifier onlyTurnDealNeeded() {\n        require(turnDealNeeded, \"No need to deal cards\");\n        _;\n    }}",
            "partition": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } uint8 public remainingWires;\nbool public gameOpen;\nuint8[6] wirePositions;\nbool public gameRunning;\nbool public turnDealNeeded;\nuint8 bombPosition;\nuint8 public numberOfPlayers;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction deal() public onlyGameRunning onlyTurnDealNeeded {\n        require(turnDealNeeded, \"There is no need to deal cards\");\n        deal_priv();\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nmodifier onlyTurnDealNeeded() {\n        require(turnDealNeeded, \"No need to deal cards\");\n        _;\n    }\n\nfunction deal_priv() internal {\n        uint8[] memory positions = dealCards(uint8(remainingWires + 1), numberOfPlayers);\n        for (uint i; i < positions.length; i++) {\n            if (i == positions.length - 1) {\n                bombPosition = positions[i];\n            } else {\n                wirePositions[i] = positions[i];\n            }\n        }\n    }\n\nfunction dealCards(uint8 positionsToGenerate, uint8 range) internal returns (uint8[] memory) {\n        require(range < 7);\n        uint8[] memory positions = new uint8[](positionsToGenerate);\n\n        // euint32 random32 = TFHE.randEuint32();\n        uint32 random32 = 0xfe; // we fix a constant value for evaluation, which cannot be used for product version.\n\n        uint8 rangeBits = getRangeBits(range); // number of bits needed at most\n\n        for (uint8 i; i < positionsToGenerate; i++) {\n            uint8 random8 = uint8(random32 >> (i * rangeBits));\n            uint256 mask = 2 ** rangeBits - 1;\n            random8 =  uint8(random8 & mask);\n            positions[i] = generateNumber(random8, range);\n        }\n        return positions;\n    }\n\nfunction getRangeBits(uint8 range) internal pure returns (uint8) {\n        uint8 rangeBits = 1;\n        if (range > 3) {\n            rangeBits = 3;\n        } else if (range > 1) {\n            rangeBits = 2;\n        }\n        return rangeBits;\n    }\n\nfunction generateNumber(uint8 random8, uint8 range) internal returns (uint8) {\n        // currently do not support random number generation \n        // return TFHE.cmux(TFHE.lt(random8, range), random8, TFHE.sub(random8, range));\n        return random8;\n    }}"
        },
        {
            "target_contract_name": "CipherBomb",
            "target_func_name": "checkDeal",
            "original": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nuint8 public numberOfPlayers;\nbool public turnDealNeeded;\nuint8 bombPosition;\nuint8 public remainingWires;\nuint8[6] wirePositions;\nmapping(address => Cards) cards;\naddress[6] public players;\nbool public gameRunning;\nuint8 public turnIndex;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction checkDeal() public onlyGameRunning onlyTurnDealNeeded {\n        bool dealIsCorrect = true;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            uint8 wires = 0;\n            for (uint8 j; j < remainingWires; j++) {\n                wires = wires + uint8(wirePositions[j]==i? 1: 0);\n            }\n            uint8 bomb = bombPosition == i ? 1 : 0;\n            uint8 neutrals = turnCardLimit() - (wires + bomb);\n            uint8 total = turnCardLimit();\n            cards[players[i]] = Cards(bomb, wires, neutrals, total);\n            dealIsCorrect = dealIsCorrect && (wires + bomb) <= turnCardLimit();\n        }\n        turnDealNeeded = !dealIsCorrect;\n        if (turnDealNeeded) {\n            emit FalseDeal();\n        } else {\n            emit GoodDeal();\n        }\n    }\n\nmodifier onlyTurnDealNeeded() {\n        require(turnDealNeeded, \"No need to deal cards\");\n        _;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nfunction turnCardLimit() internal view returns (uint8) {\n        return uint8(5 - turnIndex);\n    }}",
            "partition": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } uint8 public turnIndex;\nmapping(address => Cards) cards;\nuint8 public remainingWires;\nbool public gameOpen;\nuint8[6] wirePositions;\nbool public gameRunning;\nbool public turnDealNeeded;\nuint8 bombPosition;\nuint8 public numberOfPlayers;\naddress[6] public players;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction checkDeal() public onlyGameRunning onlyTurnDealNeeded {\n        bool flag = checkDeal_priv();\n        checkDeal_callback(flag);\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nmodifier onlyTurnDealNeeded() {\n        require(turnDealNeeded, \"No need to deal cards\");\n        _;\n    }\n\nfunction checkDeal_priv() internal returns (bool) {\n        bool dealIsCorrect = true;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            uint8 wires = 0;\n            for (uint8 j; j < remainingWires; j++) {\n                wires = wires + uint8(wirePositions[j]==i? 1: 0);\n            }\n            uint8 bomb = bombPosition == i ? 1 : 0;\n            uint8 neutrals = turnCardLimit() - (wires + bomb);\n            uint8 total = turnCardLimit();\n            cards[players[i]] = Cards(bomb, wires, neutrals, total);\n            dealIsCorrect = dealIsCorrect && (wires + bomb) <= turnCardLimit();\n        }\n        return !dealIsCorrect;\n    }\n\nfunction turnCardLimit() internal view returns (uint8) {\n        return uint8(5 - turnIndex);\n    }\n\nfunction checkDeal_callback(bool flag) internal {\n        turnDealNeeded = flag;\n        if (turnDealNeeded) {\n            emit FalseDeal();\n        } else {\n            emit GoodDeal();\n        }\n    }}"
        },
        {
            "target_contract_name": "CipherBomb",
            "target_func_name": "getRole",
            "original": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nuint8 public numberOfPlayers;\nmapping(address => bool) roles;\nbool public gameRunning;\naddress[6] public players;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getRole()\n        public\n        view\n        onlyGameRunning\n        onlyPlayer(msg.sender)\n        returns (bool)\n    {\n        address player = msg.sender;\n        return roles[player];\n    }\n\nmodifier onlyPlayer(address player) {\n        bool exists = false;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            if (players[i] == player) exists = true;\n        }\n        require(exists, \"This player doesn't exist\");\n        _;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }}",
            "partition": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nbool public gameRunning;\nuint8 public numberOfPlayers;\naddress[6] public players;\nmapping(address => bool) roles;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getRole()\n        public\n        view\n        onlyGameRunning\n        onlyPlayer(msg.sender)\n        returns (bool)\n    {\n        bool hasRole = getRole_priv();\n        return getRole_callback(hasRole);\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nmodifier onlyPlayer(address player) {\n        bool exists = false;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            if (players[i] == player) exists = true;\n        }\n        require(exists, \"This player doesn't exist\");\n        _;\n    }\n\nfunction getRole_priv()\n        internal view\n        returns (bool)\n    {\n        address player = msg.sender;\n        return roles[player];\n    }\n\nfunction getRole_callback(bool hasRole)\n        internal pure\n        returns (bool)\n    {\n        return hasRole;\n    }}"
        },
        {
            "target_contract_name": "CipherBomb",
            "target_func_name": "getCards",
            "original": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nuint8 public numberOfPlayers;\nmapping(address => Cards) cards;\naddress[6] public players;\nbool public gameRunning;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getCards() public view onlyGameRunning returns (uint8[] memory) {\n        uint8[] memory tableCards = new uint8[](numberOfPlayers);\n        for (uint8 i = 0; i < numberOfPlayers; i++) {\n            address player = players[i];\n            tableCards[i] = cards[player].total;\n        }\n        return tableCards;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }}",
            "partition": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } uint8 public numberOfPlayers;\nmapping(address => Cards) cards;\nbool public gameRunning;\nbool public gameOpen;\naddress[6] public players;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getCards() public view onlyGameRunning returns (uint8[] memory) {\n        uint8[] memory tableCards = getCards_priv();\n        return getCards_callback(tableCards);\n    }\n\nfunction getCards_priv() internal view returns (uint8[] memory) {\n        uint8[] memory tableCards = new uint8[](numberOfPlayers);\n        for (uint8 i = 0; i < numberOfPlayers; i++) {\n            address player = players[i];\n            tableCards[i] = cards[player].total;\n        }\n        return tableCards;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nfunction getCards_callback(uint8[] memory tableCards) internal pure returns (uint8[] memory) {\n        return tableCards;\n    }}"
        },
        {
            "target_contract_name": "CipherBomb",
            "target_func_name": "getMyCards",
            "original": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nuint8 public numberOfPlayers;\nmapping(address => Cards) cards;\naddress[6] public players;\nbool public gameRunning;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getMyCards(\n    )\n        public\n        view\n        onlyGameRunning\n        onlyPlayer(msg.sender)\n        returns (uint8, uint8, uint8)\n    {\n        address player = msg.sender;\n        uint8 wires = cards[player].wires;\n        uint8 bomb = cards[player].bomb;\n        uint8 neutrals = cards[player].neutrals;\n        return (wires, bomb, neutrals);\n    }\n\nmodifier onlyPlayer(address player) {\n        bool exists = false;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            if (players[i] == player) exists = true;\n        }\n        require(exists, \"This player doesn't exist\");\n        _;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }}",
            "partition": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } uint8 public numberOfPlayers;\nmapping(address => Cards) cards;\nbool public gameRunning;\nbool public gameOpen;\naddress[6] public players;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getMyCards(\n    )\n        public\n        view\n        onlyGameRunning\n        onlyPlayer(msg.sender)\n        returns (uint8, uint8, uint8)\n    {\n        address player = msg.sender;\n        (uint8 wires, uint8 bomb, uint8 neutrals) = getMyCards_priv(player);\n        return getMyCards_callback(wires, bomb, neutrals);\n    }\n\nfunction getMyCards_priv(address player)\n        internal view\n        returns (uint8, uint8, uint8)\n    {\n        uint8 wires = cards[player].wires;\n        uint8 bomb = cards[player].bomb;\n        uint8 neutrals = cards[player].neutrals;\n        return (wires, bomb, neutrals);\n    }\n\nmodifier onlyPlayer(address player) {\n        bool exists = false;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            if (players[i] == player) exists = true;\n        }\n        require(exists, \"This player doesn't exist\");\n        _;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nfunction getMyCards_callback(uint8 wires, uint8 bomb, uint8 neutrals)\n        internal pure\n        returns (uint8, uint8, uint8)\n    {\n        return (wires, bomb, neutrals);\n    }}"
        },
        {
            "target_contract_name": "CipherBomb",
            "target_func_name": "takeCard",
            "original": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } bool public gameOpen;\nuint8 public numberOfPlayers;\nbool public turnDealNeeded;\nbool public gameRoleDealNeeded;\nuint8 public turnMove;\nuint8 public remainingWires;\nmapping(address => Cards) cards;\naddress private _owner;\nbool public gameRunning;\nuint8 public turnIndex;\naddress[6] public players;\naddress public turnCurrentPlayer;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction takeCard(address player) public onlyGameRunning onlyTurnRunning onlyCurrentPlayer(msg.sender) {\n        require(cards[player].total > 0);\n        require(player != msg.sender);\n        // uint8 random8 = TFHE.shr(TFHE.randuint8(), 5);\n        uint8 random8 = 0xfe;\n        uint8 correctedCard = generateNumber(random8, cards[player].total);\n        // bool cardIsWire = TFHE.and(TFHE.gt(cards[player].wires, 0), TFHE.lt(correctedCard, cards[player].wires));\n        // bool cardIsBomb = TFHE.and(TFHE.eq(cards[player].bomb, 1), TFHE.eq(correctedCard, cards[player].wires));\n        bool cardIsWire = cards[player].wires > 0 && correctedCard < cards[player].wires;\n        bool cardIsBomb = cards[player].bomb == 1 && correctedCard == cards[player].wires;\n        \n        if (cardIsWire){\n            cards[player].wires = cards[player].wires - 1;\n        }\n        else if (cardIsBomb){\n            cards[player].bomb = cards[player].bomb - 1;\n        }\n        else{\n            cards[player].neutrals = cards[player].neutrals - 1;\n        }\n\n        cards[player].total = cards[player].total - 1;\n\n        uint8 cardType = uint8(CardType.NEUTRAL);\n\n        if (cardIsWire){\n            cardType = uint8(CardType.WIRE);\n        }\n\n        if (cardIsBomb){\n            cardType = uint8(CardType.BOMB);\n        }\n\n        turnMove++;\n\n        if (cardType == uint8(CardType.BOMB)) {\n            emit BadGuysWin(\"bomb\");\n            endGame();\n            return;\n        }\n\n        if (cardType == uint8(CardType.WIRE)) {\n            remainingWires--;\n            if (remainingWires == 0) {\n                emit GoodGuysWin();\n                endGame();\n                return;\n            }\n        }\n\n        if (turnMove == numberOfPlayers) {\n            turnIndex++;\n            if (turnIndex == 4) {\n                emit BadGuysWin(\"cards\");\n                endGame();\n                return;\n            }\n            emit Turn(turnIndex);\n            turnMove = 0;\n            turnDealNeeded = true;\n        }\n\n        emit CardPicked(cardType);\n        turnCurrentPlayer = player;\n    }\n\nfunction generateNumber(uint8 random8, uint8 range) internal returns (uint8) {\n        // currently do not support random number generation \n        // return TFHE.cmux(TFHE.lt(random8, range), random8, TFHE.sub(random8, range));\n        return random8;\n    }\n\nmodifier onlyCurrentPlayer(address player) {\n        require(turnCurrentPlayer == player, \"It's not your turn!\");\n        _;\n    }\n\nfunction endGame() internal {\n        gameRunning = false;\n        open();\n    }\n\nfunction open() public {\n        gameOpen = true;\n        gameRunning = false;\n        turnIndex = 0;\n        turnMove = 0;\n        turnDealNeeded = true;\n        gameRoleDealNeeded = true;\n        delete players;\n        numberOfPlayers = 0;\n        addPlayer(owner());\n\n        emit GameOpen();\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction addPlayer(address player) internal onlyNewPlayer(player) {\n        players[numberOfPlayers] = player;\n        numberOfPlayers++;\n    }\n\nmodifier onlyNewPlayer(address player) {\n        bool newPlayer = true;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            if (players[i] == player) newPlayer = false;\n        }\n        require(newPlayer);\n        _;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nmodifier onlyTurnRunning() {\n        require(turnMove < numberOfPlayers && !turnDealNeeded, \"Need to deal cards\");\n        _;\n    }}",
            "partition": " contract CipherBomb{\nenum CardType {\n        WIRE,\n        BOMB,\n        NEUTRAL\n    } uint8 public numberOfPlayers;\nuint8 public turnIndex;\nmapping(address => Cards) cards;\naddress public turnCurrentPlayer;\nuint8 public turnMove;\nuint8 public remainingWires;\nbool public gameRunning;\naddress private _owner;\nbool public turnDealNeeded;\nbool public gameOpen;\nbool public gameRoleDealNeeded;\naddress[6] public players;\nstruct Cards {\n        uint8 bomb;\n        uint8 wires;\n        uint8 neutrals;\n        uint8 total;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent PlayerJoined(address player);\nevent PlayerLeft(address player);\nevent PlayerKicked(address player);\nevent PlayerNameChanged(address player, string name);\nevent GameOpen();\nevent GameStart();\nevent Turn(uint8 index);\nevent CardPicked(uint8 cardType);\nevent GoodGuysWin();\nevent BadGuysWin(string reason);\nevent GoodDeal();\nevent FalseDeal();\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction takeCard(address player) public onlyGameRunning onlyTurnRunning onlyCurrentPlayer(msg.sender) {\n        require(player != msg.sender);\n        takeCard_priv(player);\n        takeCard_callback(player);\n    }\n\nfunction takeCard_callback(address player) internal {\n        turnCurrentPlayer = player;\n    }\n\nmodifier onlyCurrentPlayer(address player) {\n        require(turnCurrentPlayer == player, \"It's not your turn!\");\n        _;\n    }\n\nmodifier onlyGameRunning() {\n        require(!gameOpen && gameRunning, \"The game is not running\");\n        _;\n    }\n\nmodifier onlyTurnRunning() {\n        require(turnMove < numberOfPlayers && !turnDealNeeded, \"Need to deal cards\");\n        _;\n    }\n\nfunction takeCard_priv(address player) internal {\n        require(cards[player].total > 0);\n        // uint8 random8 = TFHE.shr(TFHE.randuint8(), 5);\n        uint8 random8 = 0xfe;\n        uint8 correctedCard = generateNumber(random8, cards[player].total);\n        // bool cardIsWire = TFHE.and(TFHE.gt(cards[player].wires, 0), TFHE.lt(correctedCard, cards[player].wires));\n        // bool cardIsBomb = TFHE.and(TFHE.eq(cards[player].bomb, 1), TFHE.eq(correctedCard, cards[player].wires));\n        bool cardIsWire = cards[player].wires > 0 && correctedCard < cards[player].wires;\n        bool cardIsBomb = cards[player].bomb == 1 && correctedCard == cards[player].wires;\n        \n        if (cardIsWire){\n            cards[player].wires = cards[player].wires - 1;\n        }\n        else if (cardIsBomb){\n            cards[player].bomb = cards[player].bomb - 1;\n        }\n        else{\n            cards[player].neutrals = cards[player].neutrals - 1;\n        }\n\n        cards[player].total = cards[player].total - 1;\n\n        uint8 cardType = uint8(CardType.NEUTRAL);\n\n        if (cardIsWire){\n            cardType = uint8(CardType.WIRE);\n        }\n\n        if (cardIsBomb){\n            cardType = uint8(CardType.BOMB);\n        }\n\n        turnMove++;\n\n        if (cardType == uint8(CardType.BOMB)) {\n            emit BadGuysWin(\"bomb\");\n            endGame();\n            return;\n        }\n\n        if (cardType == uint8(CardType.WIRE)) {\n            remainingWires--;\n            if (remainingWires == 0) {\n                emit GoodGuysWin();\n                endGame();\n                return;\n            }\n        }\n\n        if (turnMove == numberOfPlayers) {\n            turnIndex++;\n            if (turnIndex == 4) {\n                emit BadGuysWin(\"cards\");\n                endGame();\n                return;\n            }\n            emit Turn(turnIndex);\n            turnMove = 0;\n            turnDealNeeded = true;\n        }\n\n        emit CardPicked(cardType);\n    }\n\nfunction endGame() internal {\n        gameRunning = false;\n        open();\n    }\n\nfunction open() public {\n        gameOpen = true;\n        gameRunning = false;\n        turnIndex = 0;\n        turnMove = 0;\n        turnDealNeeded = true;\n        gameRoleDealNeeded = true;\n        delete players;\n        numberOfPlayers = 0;\n        addPlayer(owner());\n\n        emit GameOpen();\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction addPlayer(address player) internal onlyNewPlayer(player) {\n        players[numberOfPlayers] = player;\n        numberOfPlayers++;\n    }\n\nmodifier onlyNewPlayer(address player) {\n        bool newPlayer = true;\n        for (uint8 i; i < numberOfPlayers; i++) {\n            if (players[i] == player) newPlayer = false;\n        }\n        require(newPlayer);\n        _;\n    }\n\nfunction generateNumber(uint8 random8, uint8 range) internal returns (uint8) {\n        // currently do not support random number generation \n        // return TFHE.cmux(TFHE.lt(random8, range), random8, TFHE.sub(random8, range));\n        return random8;\n    }}"
        }
    ],
    "DarkPool": [
        {
            "target_contract_name": "DarkPool",
            "target_func_name": "deposit",
            "original": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(uint8 => uint32)) public balances;\nIERC20[] public tokens;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction deposit(uint8 tokenId, uint32 amount) public {\n        tokens[tokenId].transferFrom(msg.sender, address(this), amount);\n\n        uint32 prevBalance = balances[msg.sender][tokenId];\n        balances[msg.sender][tokenId] = prevBalance + amount;\n    }}",
            "partition": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(uint8 => uint32)) public balances;\nIERC20[] public tokens;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction deposit(uint8 tokenId, uint32 amount) public {\n        tokens[tokenId].transferFrom(msg.sender, address(this), amount);\n\n        deposit_priv(msg.sender, tokenId, amount);\n    }\n\nfunction deposit_priv(address sender, uint8 tokenId, uint32 amount) internal {\n        uint32 prevBalance = balances[sender][tokenId];\n        balances[sender][tokenId] = prevBalance + amount;\n    }}"
        },
        {
            "target_contract_name": "DarkPool",
            "target_func_name": "createOrder",
            "original": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } uint8 public constant BASE_INDEX = 0;\nuint8 public constant QUOTE_INDEX = 1;\nmapping(address => mapping(OrderType => Order)) public orders;\nmapping(address => mapping(uint8 => uint32)) public balances;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction createOrder(OrderType orderType, uint32 amount, uint32 price) public {\n        _createOrder(orderType, amount, price);\n    }\n\nfunction _createOrder(OrderType orderType, uint32 amount, uint32 price) internal {\n        // ensure there is no existing order\n        require(orders[msg.sender][orderType].amount != 0);\n\n        if (orderType == OrderType.Buy) {\n            // ensure amount * price <= quote balance\n            require(amount * price <= balances[msg.sender][QUOTE_INDEX]);\n        } else {\n            // ensure amount <= base balance\n            require(amount <= balances[msg.sender][BASE_INDEX]);\n        }\n        // create sell order\n        orders[msg.sender][orderType] = Order(amount, price);\n        emit OrderCreated(msg.sender, uint8(orderType), amount, price);\n    }}",
            "partition": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(uint8 => uint32)) public balances;\nuint8 public constant BASE_INDEX = 0;\nuint8 public constant QUOTE_INDEX = 1;\nmapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction createOrder(OrderType orderType, uint32 amount, uint32 price) public {\n        createOrder_priv(orderType, amount, price);\n    }\n\nfunction createOrder_priv(OrderType orderType, uint32 amount, uint32 price) public {\n        _createOrder(orderType, amount, price);\n    }\n\nfunction _createOrder(OrderType orderType, uint32 amount, uint32 price) internal {\n        // ensure there is no existing order\n        require(orders[msg.sender][orderType].amount != 0);\n\n        if (orderType == OrderType.Buy) {\n            // ensure amount * price <= quote balance\n            require(amount * price <= balances[msg.sender][QUOTE_INDEX]);\n        } else {\n            // ensure amount <= base balance\n            require(amount <= balances[msg.sender][BASE_INDEX]);\n        }\n        // create sell order\n        orders[msg.sender][orderType] = Order(amount, price);\n        emit OrderCreated(msg.sender, uint8(orderType), amount, price);\n    }}"
        },
        {
            "target_contract_name": "DarkPool",
            "target_func_name": "fillOrder",
            "original": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } uint8 public constant BASE_INDEX = 0;\nuint8 public constant QUOTE_INDEX = 1;\nmapping(address => mapping(OrderType => Order)) public orders;\nmapping(address => mapping(uint8 => uint32)) public balances;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction fillOrder(address buyer, address seller) public {\n        Order memory buyOrder = orders[buyer][OrderType.Buy];\n        Order memory sellOrder = orders[seller][OrderType.Sell];\n\n        \n        // ensure neither order is empty\n        require(buyOrder.amount != 0);\n        require(sellOrder.amount != 0);\n\n        // ensure prices are the same\n        require(buyOrder.price == sellOrder.price);\n\n        // Check which order is larger\n        bool buyOrderLarger = sellOrder.amount <= buyOrder.amount;\n\n        // Get the amount being traded\n        uint32 baseAmount = buyOrderLarger? sellOrder.amount : buyOrder.amount;\n        uint32 quoteAmount = baseAmount * sellOrder.price;\n\n        /* Adjust order amounts */\n        // Subtract amount filled from each order\n        orders[buyer][OrderType.Buy].amount = buyOrder.amount - baseAmount;\n        orders[seller][OrderType.Sell].amount = sellOrder.amount - baseAmount;\n\n        // Adjust base balances\n        balances[seller][BASE_INDEX] = balances[seller][BASE_INDEX] - baseAmount;\n        balances[buyer][BASE_INDEX] = balances[buyer][BASE_INDEX] + baseAmount;\n\n        // Adjust quote balances\n        balances[seller][QUOTE_INDEX] = balances[seller][QUOTE_INDEX] + quoteAmount;\n        balances[buyer][QUOTE_INDEX] = balances[buyer][QUOTE_INDEX] - quoteAmount;\n\n        // Remove price of filled orders\n        orders[buyer][OrderType.Buy].price = buyOrder.amount <= 0? 0: buyOrder.price;\n        orders[seller][OrderType.Sell].price = sellOrder.amount <= 0? 0: sellOrder.price;\n\n        emit OrderUpdated(\n            buyer, uint8(OrderType.Buy), orders[buyer][OrderType.Buy].amount, orders[buyer][OrderType.Buy].price\n        );\n        emit OrderUpdated(\n            seller, uint8(OrderType.Sell), orders[seller][OrderType.Sell].amount, orders[seller][OrderType.Sell].price\n        );\n    }}",
            "partition": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(uint8 => uint32)) public balances;\nuint8 public constant BASE_INDEX = 0;\nuint8 public constant QUOTE_INDEX = 1;\nmapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction fillOrder(address buyer, address seller) public {\n        fillOrder_priv(buyer, seller);\n    }\n\nfunction fillOrder_priv(address buyer, address seller) internal {\n        Order memory buyOrder = orders[buyer][OrderType.Buy];\n        Order memory sellOrder = orders[seller][OrderType.Sell];\n\n        \n        // ensure neither order is empty\n        require(buyOrder.amount != 0);\n        require(sellOrder.amount != 0);\n\n        // ensure prices are the same\n        require(buyOrder.price == sellOrder.price);\n\n        // Check which order is larger\n        bool buyOrderLarger = sellOrder.amount <= buyOrder.amount;\n\n        // Get the amount being traded\n        uint32 baseAmount = buyOrderLarger? sellOrder.amount : buyOrder.amount;\n        uint32 quoteAmount = baseAmount * sellOrder.price;\n\n        /* Adjust order amounts */\n        // Subtract amount filled from each order\n        orders[buyer][OrderType.Buy].amount = buyOrder.amount - baseAmount;\n        orders[seller][OrderType.Sell].amount = sellOrder.amount - baseAmount;\n\n        // Adjust base balances\n        balances[seller][BASE_INDEX] = balances[seller][BASE_INDEX] - baseAmount;\n        balances[buyer][BASE_INDEX] = balances[buyer][BASE_INDEX] + baseAmount;\n\n        // Adjust quote balances\n        balances[seller][QUOTE_INDEX] = balances[seller][QUOTE_INDEX] + quoteAmount;\n        balances[buyer][QUOTE_INDEX] = balances[buyer][QUOTE_INDEX] - quoteAmount;\n\n        // Remove price of filled orders\n        orders[buyer][OrderType.Buy].price = buyOrder.amount <= 0? 0: buyOrder.price;\n        orders[seller][OrderType.Sell].price = sellOrder.amount <= 0? 0: sellOrder.price;\n\n        emit OrderUpdated(\n            buyer, uint8(OrderType.Buy), orders[buyer][OrderType.Buy].amount, orders[buyer][OrderType.Buy].price\n        );\n        emit OrderUpdated(\n            seller, uint8(OrderType.Sell), orders[seller][OrderType.Sell].amount, orders[seller][OrderType.Sell].price\n        );\n    }}"
        },
        {
            "target_contract_name": "DarkPool",
            "target_func_name": "deleteOrder",
            "original": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction deleteOrder(address user, OrderType orderType) public {\n        Order memory order = orders[user][orderType];\n\n        // ensure order exists\n        // require(TFHE.isInitialized(order.amount), \"Order does not exist\");\n\n        // ensure order is empty\n        require(order.amount == 0);\n\n        // delete order\n        delete orders[user][orderType];\n\n        emit OrderDeleted(user, uint8(orderType));\n    }}",
            "partition": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction deleteOrder(address user, OrderType orderType) public {\n        deleteOrder_priv(user, orderType);\n    }\n\nfunction deleteOrder_priv(address user, OrderType orderType) public {\n        Order memory order = orders[user][orderType];\n\n        // ensure order exists\n        // require(TFHE.isInitialized(order.amount), \"Order does not exist\");\n\n        // ensure order is empty\n        require(order.amount == 0);\n\n        // delete order\n        delete orders[user][orderType];\n\n        emit OrderDeleted(user, uint8(orderType));\n    }}"
        },
        {
            "target_contract_name": "DarkPool",
            "target_func_name": "retractOrder",
            "original": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction retractOrder(OrderType orderType) public {\n        delete orders[msg.sender][orderType];\n        emit OrderDeleted(msg.sender, uint8(orderType));\n    }}",
            "partition": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction retractOrder(OrderType orderType) public {\n        retractOrder_priv(msg.sender, orderType);\n    }\n\nfunction retractOrder_priv(address user, OrderType orderType) internal {\n        delete orders[user][orderType];\n        emit OrderDeleted(user, uint8(orderType));\n    }}"
        },
        {
            "target_contract_name": "DarkPool",
            "target_func_name": "getBalance",
            "original": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(uint8 => uint32)) public balances;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction getBalance(uint8 tokenId) public view returns (uint32) {\n        return balances[msg.sender][tokenId];\n    }}",
            "partition": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(uint8 => uint32)) public balances;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction getBalance(uint8 tokenId) public view returns (uint32) {\n        uint32 balance = getBalance_priv(msg.sender, tokenId);\n        return getBalance_callback(balance);\n    }\n\nfunction getBalance_callback(uint32 balance) internal pure returns (uint32) {\n        return balance;\n    }\n\nfunction getBalance_priv(address user, uint8 tokenId) public view returns (uint32) {\n        return balances[user][tokenId];\n    }}"
        },
        {
            "target_contract_name": "DarkPool",
            "target_func_name": "withdraw",
            "original": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } uint8 public constant BASE_INDEX = 0;\nmapping(address => mapping(uint8 => uint32)) public balances;\nIERC20[] public tokens;\nmapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction withdraw(uint8 tokenId, uint32 amount) public {\n        if (tokenId == BASE_INDEX) {\n            // ensure the user doesn't have an open sell order\n              require(\n                orders[msg.sender][OrderType.Sell].amount == 0,\n                \"Close sell order before withdrawing base\"\n            );\n        } else {\n            // ensure the user doesn't have an open buy order\n            require(\n                orders[msg.sender][OrderType.Buy].amount == 0,\n                \"Close buy order before withdrawing quote\"\n            );\n        }\n\n        // ensure user has enough balance\n        require(balances[msg.sender][tokenId] >= amount);\n        // transfer tokens\n        tokens[tokenId].transfer(msg.sender, amount);\n        // update balance\n        balances[msg.sender][tokenId] = balances[msg.sender][tokenId] - amount;\n    }}",
            "partition": " contract DarkPool{\nenum OrderType {\n        Buy,\n        Sell\n    } mapping(address => mapping(uint8 => uint32)) public balances;\nuint8 public constant BASE_INDEX = 0;\nIERC20[] public tokens;\nmapping(address => mapping(OrderType => Order)) public orders;\nstruct Order {\n        uint32 amount; // Amount of base to buy/sell\n        uint32 price; // Price of base asset to buy/sell at (e.g 2000 USDC/ETH)\n    }\nevent OrderCreated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderUpdated(address indexed user, uint8 orderType, uint32 amount, uint32 price);\nevent OrderDeleted(address indexed user, uint8 orderType);\n\nfunction withdraw(uint8 tokenId, uint32 amount) public {\n        withdraw_priv(msg.sender, tokenId, amount);\n    }\n\nfunction withdraw_priv(address user, uint8 tokenId, uint32 amount) internal {\n        if (tokenId == BASE_INDEX) {\n            // ensure the user doesn't have an open sell order\n              require(\n                orders[user][OrderType.Sell].amount == 0,\n                \"Close sell order before withdrawing base\"\n            );\n        } else {\n            // ensure the user doesn't have an open buy order\n            require(\n                orders[user][OrderType.Buy].amount == 0,\n                \"Close buy order before withdrawing quote\"\n            );\n        }\n\n        // ensure user has enough balance\n        require(balances[user][tokenId] >= amount);\n        // transfer tokens\n        tokens[tokenId].transfer(user, amount);\n        // update balance\n        balances[user][tokenId] = balances[user][tokenId] - amount;\n    }}"
        }
    ],
    "IdentityRegistry": [
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "addRegistrar",
            "original": " contract IdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addRegistrar(address wallet, uint registrarId) public onlyOwner {\n        require(registrarId > 0, \"registrarId needs to be > 0\");\n        registrars[wallet] = registrarId;\n        emit NewRegistrar(wallet, registrarId);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}",
            "partition": " contract IdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addRegistrar(address wallet, uint registrarId) public onlyOwner {\n       addRegistrar_priv(wallet,registrarId);\n    }\n\nfunction addRegistrar_priv(address wallet, uint registrarId) internal {\n        require(registrarId > 0, \"registrarId needs to be > 0\");\n        registrars[wallet] = registrarId;\n        emit NewRegistrar(wallet, registrarId);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}"
        },
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "removeRegistrar",
            "original": " contract IdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeRegistrar(address wallet) public onlyOwner {\n        require(registrars[wallet] > 0, \"wallet is not registrar\");\n        registrars[wallet] = 0;\n        emit RemoveRegistrar(wallet);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}",
            "partition": " contract IdentityRegistry{\n address private _owner;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeRegistrar(address wallet) public onlyOwner {\n        removeRegistrar_priv(wallet);\n    }\n\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\nfunction _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nfunction removeRegistrar_priv(address wallet) internal {\n        require(registrars[wallet] > 0, \"wallet is not registrar\");\n        registrars[wallet] = 0;\n        emit RemoveRegistrar(wallet);\n    }}"
        },
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "addDid",
            "original": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addDid(address wallet) public onlyRegistrar {\n        require(\n            identities[wallet].registrarId == 0,\n            \"This wallet is already registered\"\n        );\n        Identity storage newIdentity = identities[wallet];\n        newIdentity.registrarId = registrars[msg.sender];\n        emit NewDid(wallet);\n    }\n\nmodifier onlyRegistrar() {\n        require(registrars[msg.sender] > 0, \"You're not a registrar\");\n        _;\n    }}",
            "partition": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction addDid(address wallet) public onlyRegistrar {\n        uint registrarId = registrars[msg.sender];\n        addDid_priv(wallet, registrarId);\n    }\n\nmodifier onlyRegistrar() {\n        require(registrars[msg.sender] > 0, \"You're not a registrar\");\n        _;\n    }\n\nfunction addDid_priv(address wallet, uint registrarId) internal {\n        require(\n            identities[wallet].registrarId == 0,\n            \"This wallet is already registered\"\n        );\n        Identity storage newIdentity = identities[wallet];\n        newIdentity.registrarId = registrarId;\n        emit NewDid(wallet);\n    }}"
        },
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "removeDid",
            "original": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeDid(\n        address wallet\n    ) public onlyExistingWallet(wallet) onlyRegistrarOf(wallet) {\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            identities[wallet].identifiers[identifierList_[i]] = 0;\n        }\n        delete identities[wallet];\n        emit RemoveDid(wallet);\n    }\n\nmodifier onlyRegistrarOf(address wallet) {\n        uint registrarId = registrars[msg.sender];\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        _;\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}",
            "partition": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeDid(\n        address wallet\n    ) public {\n        uint registrarId = registrars[msg.sender];\n        removeDid_priv(wallet, registrarId);\n    }\n\nfunction removeDid_priv(\n        address wallet, uint registrarId\n    ) internal onlyExistingWallet(wallet) {\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            identities[wallet].identifiers[identifierList_[i]] = 0;\n        }\n        delete identities[wallet];\n        emit RemoveDid(wallet);\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}"
        },
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "setIdentifier",
            "original": " contract IdentityRegistry{\n uint constant MAX_IDENTIFIERS_LENGTH = 20;\nmapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction setIdentifier(\n        address wallet,\n        string memory identifier,\n        uint64 value\n    ) external onlyExistingWallet(wallet) onlyRegistrarOf(wallet) {\n        identities[wallet].identifiers[identifier] = value;\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) return;\n        }\n        require(\n            identifierLength + 1 <= MAX_IDENTIFIERS_LENGTH,\n            \"Too many identifiers\"\n        );\n        identities[wallet].identifierList.push(identifier);\n    }\n\nmodifier onlyRegistrarOf(address wallet) {\n        uint registrarId = registrars[msg.sender];\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        _;\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}",
            "partition": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nuint constant MAX_IDENTIFIERS_LENGTH = 20;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction setIdentifier(\n        address wallet,\n        string memory identifier,\n        uint64 value\n    ) external {\n        uint registrarId = registrars[msg.sender];\n\n        setIdentifier_priv(wallet, identifier, value, registrarId);\n    }\n\nfunction setIdentifier_priv(\n        address wallet,\n        string memory identifier,\n        uint64 value,\n        uint registrarId\n    ) internal onlyExistingWallet(wallet) {\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        identities[wallet].identifiers[identifier] = value;\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) return;\n        }\n        require(\n            identifierLength + 1 <= MAX_IDENTIFIERS_LENGTH,\n            \"Too many identifiers\"\n        );\n        identities[wallet].identifierList.push(identifier);\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}"
        },
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "removeIdentifier",
            "original": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeIdentifier(\n        address wallet,\n        string memory identifier\n    ) external onlyExistingWallet(wallet) onlyRegistrarOf(wallet) {\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) {\n                identities[wallet].identifierList[i] = identities[wallet]\n                    .identifierList[identifierLength - 1];\n                identities[wallet].identifierList.pop();\n                return;\n            }\n        }\n        require(false, \"Identifier not found\");\n    }\n\nmodifier onlyRegistrarOf(address wallet) {\n        uint registrarId = registrars[msg.sender];\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        _;\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}",
            "partition": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nmapping(address => uint) public registrars;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction removeIdentifier(\n        address wallet,\n        string memory identifier\n    ) external {\n        uint registrarId = registrars[msg.sender];\n\n        removeIdentifier_priv(wallet, identifier, registrarId);\n    }\n\nfunction removeIdentifier_priv(\n        address wallet,\n        string memory identifier,\n        uint registrarId\n    ) internal onlyExistingWallet(wallet) {\n        require(\n            identities[wallet].registrarId == registrarId,\n            \"You're not managing this identity\"\n        );\n        string[] memory identifierList_ = identities[wallet].identifierList;\n        uint identifierLength = identifierList_.length;\n        for (uint i; i < identifierLength; i++) {\n            if (\n                keccak256(bytes(identities[wallet].identifierList[i])) ==\n                keccak256(bytes(identifier))\n            ) {\n                identities[wallet].identifierList[i] = identities[wallet]\n                    .identifierList[identifierLength - 1];\n                identities[wallet].identifierList.pop();\n                return;\n            }\n        }\n        require(false, \"Identifier not found\");\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}"
        },
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "getRegistrar",
            "original": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getRegistrar(address wallet) public view returns (uint) {\n        return identities[wallet].registrarId;\n    }}",
            "partition": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getRegistrar(address wallet) public view returns (uint) {\n        uint registrarId = getRegistrar_priv(wallet);\n        return getRegistrar_callback(registrarId);\n    }\n\nfunction getRegistrar_priv(address wallet) public view returns (uint) {\n        return identities[wallet].registrarId;\n    }\n\nfunction getRegistrar_callback(uint registrarId) public view returns (uint) {\n        return registrarId;\n    }}"
        },
        {
            "target_contract_name": "IdentityRegistry",
            "target_func_name": "getIdentifier",
            "original": " contract IdentityRegistry{\n address private _owner;\nmapping(address => Identity) internal identities;\nmapping(address => mapping(address => mapping(string => bool))) permissions;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getIdentifier(\n        address wallet,\n        string calldata identifier\n    )\n        public\n        view\n        returns (uint64)\n    {\n       return _getIdentifier(wallet, identifier);\n    }\n\nfunction _getIdentifier(\n        address wallet,\n        string calldata identifier\n    ) internal view onlyExistingWallet(wallet) onlyAllowed(wallet, identifier) returns (uint64) {\n        return identities[wallet].identifiers[identifier];\n    }\n\nmodifier onlyAllowed(address wallet, string memory identifier) {\n        require(\n            owner() == msg.sender ||\n                permissions[wallet][msg.sender][identifier],\n            \"User didn't give you permission to access this identifier.\"\n        );\n        _;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }}",
            "partition": " contract IdentityRegistry{\n mapping(address => Identity) internal identities;\naddress private _owner;\nmapping(address => mapping(address => mapping(string => bool))) permissions;\nstruct Identity {\n        uint registrarId;\n        mapping(string => uint64) identifiers;\n        string[] identifierList;\n    }\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\nevent NewRegistrar(address wallet, uint registrarId);\nevent RemoveRegistrar(address wallet);\nevent NewDid(address wallet);\nevent RemoveDid(address wallet);\nerror OwnableUnauthorizedAccount(address account);\nerror OwnableInvalidOwner(address owner);\nfunction getIdentifier(\n        address wallet,\n        string calldata identifier\n    )\n        public\n        onlyAllowed(wallet, identifier)\n        returns (uint64)\n    {\n        uint64 id = getIdentifier_priv(wallet, identifier);\n        return getIdentifier_callback(id);\n    }\n\nfunction getIdentifier_priv(\n        address wallet,\n        string calldata identifier\n    )\n        public\n        onlyExistingWallet(wallet)\n        returns (uint64)\n    {\n        return\n            identities[wallet].identifiers[identifier];\n    }\n\nmodifier onlyExistingWallet(address wallet) {\n        require(\n            identities[wallet].registrarId > 0,\n            \"This wallet isn't registered\"\n        );\n        _;\n    }\n\nfunction getIdentifier_callback(uint64 id) public view returns (uint64) {\n        return id;\n    }\n\nmodifier onlyAllowed(address wallet, string memory identifier) {\n        require(\n            owner() == msg.sender ||\n                permissions[wallet][msg.sender][identifier],\n            \"User didn't give you permission to access this identifier.\"\n        );\n        _;\n    }\n\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }}"
        }
    ],
    "VickreyAuction": [
        {
            "target_contract_name": "VickreyAuction",
            "target_func_name": "bid",
            "original": " contract VickreyAuction{\n uint32 internal secondHighestBid;\nEncryptedERC20 public tokenContract;\nuint public bidCounter;\nmapping(address => uint32) public bids;\nbool public manuallyStopped = false;\nuint32 internal highestBid;\nuint public endTime;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction bid( uint32 value) public onlyBeforeEnd {\n        uint32 existingBid = bids[msg.sender];\n        if (existingBid>0) {\n            bool isHigher = existingBid < value;\n            // Update bid with value\n            if (isHigher){\n                bids[msg.sender] = value;\n            }\n            // Transfer only the difference between existing and value\n            uint32 toTransfer = value - existingBid;\n            // Transfer only if bid is higher\n            uint32 amount = isHigher? toTransfer:0;\n            tokenContract.transferFrom(msg.sender, address(this), amount);\n        } else {\n            bidCounter++;\n            bids[msg.sender] = value;\n            tokenContract.transferFrom(msg.sender, address(this), value);\n        }\n        uint32 currentBid = bids[msg.sender];\n\n        if (highestBid!=0 && secondHighestBid!=0) {\n            highestBid = currentBid;\n        } else {\n            uint32 currentHighestBid = highestBid;\n            // If the current bid is higher than the current highest bid,\n            // update the highest to the current bid and` the second highest to the previous highest bid\n            highestBid = currentHighestBid < currentBid? currentBid: currentHighestBid;\n            secondHighestBid = currentHighestBid < currentBid? currentHighestBid: currentBid;\n        }\n    }\n\nmodifier onlyBeforeEnd() {\n        if (block.timestamp >= endTime || manuallyStopped == true) revert TooLate(endTime);\n        _;\n    }}",
            "partition": " contract VickreyAuction{\n EncryptedERC20 public tokenContract;\nuint public endTime;\nmapping(address => uint32) public bids;\nuint32 internal highestBid;\nuint32 internal secondHighestBid;\nuint public bidCounter;\nbool public manuallyStopped = false;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction bid( uint32 value) public onlyBeforeEnd {\n        bool bidIncrease = bid_priv(msg.sender, value);\n        bid_callback(bidIncrease);\n    }\n\nfunction bid_priv(address sender, uint32 value) internal returns (bool){\n        bool bidIncrease = false;\n        uint32 existingBid = bids[sender];\n        if (existingBid>0) {\n            bool isHigher = existingBid < value;\n            // Update bid with value\n            if (isHigher){\n                bids[sender] = value;\n            }\n            // Transfer only the difference between existing and value\n            uint32 toTransfer = value - existingBid;\n            // Transfer only if bid is higher\n            uint32 amount = isHigher? toTransfer:0;\n            tokenContract.transferFrom(sender, address(this), amount);\n        } else {\n            bidIncrease = true;\n            bids[sender] = value;\n            tokenContract.transferFrom(sender, address(this), value);\n        }\n        uint32 currentBid = bids[sender];\n\n        if (highestBid!=0 && secondHighestBid!=0) {\n            highestBid = currentBid;\n        } else {\n            uint32 currentHighestBid = highestBid;\n            // If the current bid is higher than the current highest bid,\n            // update the highest to the current bid and` the second highest to the previous highest bid\n            highestBid = currentHighestBid < currentBid? currentBid: currentHighestBid;\n            secondHighestBid = currentHighestBid < currentBid? currentHighestBid: currentBid;\n        }\n        return bidIncrease;\n    }\n\nmodifier onlyBeforeEnd() {\n        if (block.timestamp >= endTime || manuallyStopped == true) revert TooLate(endTime);\n        _;\n    }\n\nfunction bid_callback(bool bidIncrease) internal {\n        if (bidIncrease) {\n            bidCounter++;\n        }\n    }}"
        },
        {
            "target_contract_name": "VickreyAuction",
            "target_func_name": "getBid",
            "original": " contract VickreyAuction{\n mapping(address => uint32) public bids;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction getBid(\n    ) public view  returns (uint32) {\n        return bids[msg.sender];\n    }}",
            "partition": " contract VickreyAuction{\n mapping(address => uint32) public bids;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction getBid(\n    ) public view  returns (uint32) {\n        uint32 bidPrice = getBid_priv(msg.sender);\n        return getBid_callback(bidPrice);\n    }\n\nfunction getBid_priv( address bidder ) internal view returns (uint32) {\n        return bids[bidder];\n    }\n\nfunction getBid_callback(uint32 bidPrice) internal pure  returns (uint32) {\n        return bidPrice;\n    }}"
        },
        {
            "target_contract_name": "VickreyAuction",
            "target_func_name": "doIHaveHighestBid",
            "original": " contract VickreyAuction{\n bool public manuallyStopped = false;\nuint32 internal highestBid;\nuint public endTime;\nmapping(address => uint32) public bids;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction doIHaveHighestBid(\n    ) public view onlyAfterEnd returns (bool) {\n        if (highestBid!=0 && bids[msg.sender]!=0) {\n            return highestBid <= bids[msg.sender];\n        } else {\n            return false;\n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp <= endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract VickreyAuction{\n mapping(address => uint32) public bids;\nuint32 internal highestBid;\nbool public manuallyStopped = false;\nuint public endTime;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction doIHaveHighestBid(\n    ) public view onlyAfterEnd returns (bool) {\n       bool flag = doIHaveHighestBid_priv(msg.sender);\n       return doIHaveHighestBid_callback(flag);\n    }\n\nfunction doIHaveHighestBid_callback(bool flag) internal pure returns (bool) {\n        return flag;\n    }\n\nfunction doIHaveHighestBid_priv(address sender\n    ) internal view returns (bool) {\n        if (highestBid!=0 && bids[sender]!=0) {\n            return highestBid <= bids[sender];\n        } else {\n            return false;\n        }\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp <= endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}"
        },
        {
            "target_contract_name": "VickreyAuction",
            "target_func_name": "auctionEnd",
            "original": " contract VickreyAuction{\n uint32 internal secondHighestBid;\nEncryptedERC20 public tokenContract;\nuint256 public nftId;\nbool public tokenTransferred;\nIERC721 public nft;\nbool public manuallyStopped = false;\nuint32 internal highestBid;\nuint public endTime;\naddress public beneficiary;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction auctionEnd() public onlyAfterEnd {\n        require(!tokenTransferred);\n\n        // revert if the nft has not been transferred to the contract\n        if (nft.ownerOf(nftId) != address(this)) {\n            revert NotNFTTransfered(address(nft), nftId);\n        }\n\n        tokenTransferred = true;\n        tokenContract.transfer(beneficiary, secondHighestBid);\n        emit AuctionEnded(highestBid, secondHighestBid);\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp <= endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract VickreyAuction{\n EncryptedERC20 public tokenContract;\nuint public endTime;\nuint32 internal highestBid;\nbool public tokenTransferred;\nuint256 public nftId;\nIERC721 public nft;\nuint32 internal secondHighestBid;\naddress public beneficiary;\nbool public manuallyStopped = false;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction auctionEnd() public onlyAfterEnd {\n        require(!tokenTransferred);\n\n        // revert if the nft has not been transferred to the contract\n        if (nft.ownerOf(nftId) != address(this)) {\n            revert NotNFTTransfered(address(nft), nftId);\n        }\n\n        tokenTransferred = true;\n        auctionEnd_priv();\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp <= endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }\n\nfunction auctionEnd_priv() internal {\n        tokenContract.transfer(beneficiary, secondHighestBid);\n        emit AuctionEnded(highestBid, secondHighestBid);\n    }}"
        },
        {
            "target_contract_name": "VickreyAuction",
            "target_func_name": "claim",
            "original": " contract VickreyAuction{\n uint32 internal secondHighestBid;\nEncryptedERC20 public tokenContract;\nuint256 public nftId;\nIERC721 public nft;\nmapping(address => uint32) public bids;\nbool public manuallyStopped = false;\nbool public objectClaimed;\nuint32 internal highestBid;\nuint public endTime;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction claim() public onlyAfterEnd {\n        bool canClaimAsWinner = highestBid == bids[msg.sender] && !objectClaimed;\n\n        if (canClaimAsWinner) {\n            // if the caller has the highest bid and not claimed, then claim the object\n            // and set the objectClaimed to true\n            objectClaimed = canClaimAsWinner;\n\n            nft.safeTransferFrom(address(this), msg.sender, nftId);\n        }\n        // Update the bid to the difference between the highest and second highest bid\n        // if the caller has the highest bid, otherwise keep the bid value as is\n        bids[msg.sender] = canClaimAsWinner? highestBid - secondHighestBid: bids[msg.sender];\n        // If the caller does not have the highest bid, then withdraw the bid\n        _withdraw();\n    }\n\nfunction _withdraw() internal onlyAfterEnd {\n        uint32 bidValue = bids[msg.sender];\n\n        // Update the bid mapping to 0\n        bids[msg.sender] = 0;\n\n        // Transfer the bid value to the caller\n        bool isTransferd = tokenContract.transfer(msg.sender, bidValue);\n\n        // Revert if the transfer failed\n        require(isTransferd, \"Transfer failed\");\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp <= endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}",
            "partition": " contract VickreyAuction{\n EncryptedERC20 public tokenContract;\nuint public endTime;\nmapping(address => uint32) public bids;\nuint32 internal highestBid;\nbool public objectClaimed;\nuint256 public nftId;\nIERC721 public nft;\nuint32 internal secondHighestBid;\nbool public manuallyStopped = false;\n\nevent AuctionEnded(uint32 indexed highestBid, uint32 indexed secondHighestBid);\nerror TooEarly(uint time);\nerror TooLate(uint time);\nerror NotNFTTransfered(address tokenAddress, uint256 tokenId);\nfunction claim() public onlyAfterEnd {\n        claim_priv(msg.sender);\n    }\n\nfunction claim_priv(address sender) internal {\n        bool canClaimAsWinner = highestBid == bids[sender] && !objectClaimed;\n\n        if (canClaimAsWinner) {\n            // if the caller has the highest bid and not claimed, then claim the object\n            // and set the objectClaimed to true\n            objectClaimed = canClaimAsWinner;\n\n            nft.safeTransferFrom(address(this), sender, nftId);\n        }\n        // Update the bid to the difference between the highest and second highest bid\n        // if the caller has the highest bid, otherwise keep the bid value as is\n        bids[sender] = canClaimAsWinner? highestBid - secondHighestBid: bids[sender];\n        // If the caller does not have the highest bid, then withdraw the bid\n        _withdraw(sender);\n    }\n\nfunction _withdraw(address sender) internal {\n        uint32 bidValue = bids[sender];\n\n        // Update the bid mapping to 0\n        bids[sender] = 0;\n\n        // Transfer the bid value to the caller\n        bool isTransferd = tokenContract.transfer(sender, bidValue);\n\n        // Revert if the transfer failed\n        require(isTransferd, \"Transfer failed\");\n    }\n\nmodifier onlyAfterEnd() {\n        if (block.timestamp <= endTime && manuallyStopped == false) revert TooEarly(endTime);\n        _;\n    }}"
        }
    ],
    "Comp": [
        {
            "target_contract_name": "Comp",
            "target_func_name": "approve",
            "original": " contract Comp{\n mapping(address => mapping(address => uint64)) internal allowances;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction approve(address spender, uint64 amount) external returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, amount);\n        return true;\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal {\n        emit Approval(owner, spender, amount);\n        allowances[owner][spender] = amount;\n    }}",
            "partition": " contract Comp{\n mapping(address => mapping(address => uint64)) internal allowances;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction approve(address spender, uint64 amount) external returns (bool) {\n        address owner = msg.sender;\n        approve_priv(owner, spender, amount);\n        return true;\n    }\n\nfunction approve_priv(address owner, address spender, uint64 amount) internal  {\n        _approve(owner, spender, amount);\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal {\n        emit Approval(owner, spender, amount);\n        allowances[owner][spender] = amount;\n    }}"
        },
        {
            "target_contract_name": "Comp",
            "target_func_name": "transfer",
            "original": " contract Comp{\n mapping(address => address) public delegates;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint64) internal balances;\nmapping(address => uint32) public numCheckpoints;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction transfer(address to, uint64 amount) public {\n        _transfer(msg.sender, to, amount);\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal {\n        // Make sure the sender has enough tokens.\n        bool canTransfer = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (canTransfer){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n            _moveDelegates(delegates[from], delegates[to], amount);\n        }\n    \n       \n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}",
            "partition": " contract Comp{\n mapping(address => address) public delegates;\nmapping(address => uint32) public numCheckpoints;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint64) internal balances;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction transfer(address to, uint64 amount) public {\n        transfer_priv(msg.sender, to, amount);\n    }\n\nfunction transfer_priv(address from, address to, uint64 amount) internal {\n        _transfer(from, to, amount);\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal {\n        // Make sure the sender has enough tokens.\n        bool canTransfer = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (canTransfer){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n            _moveDelegates(delegates[from], delegates[to], amount);\n        }\n    \n       \n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}"
        },
        {
            "target_contract_name": "Comp",
            "target_func_name": "transferFrom",
            "original": " contract Comp{\n mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => mapping(address => uint64)) internal allowances;\nmapping(address => uint32) public numCheckpoints;\nmapping(address => uint64) internal balances;\nmapping(address => address) public delegates;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction transferFrom(address from, address to, uint64 amount) public returns (bool) {\n        address spender = msg.sender;\n        _updateAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\nfunction _updateAllowance(address owner, address spender, uint64 amount) internal {\n        uint64 currentAllowance = _allowance(owner, spender);\n        bool canApprove = amount <= currentAllowance;\n        if (canApprove) {\n            _approve(owner, spender, currentAllowance - amount);\n        }else{\n            _approve(owner, spender, 0);\n        }\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal {\n        emit Approval(owner, spender, amount);\n        allowances[owner][spender] = amount;\n    }\n\nfunction _allowance(address owner, address spender) internal view returns (uint64) {\n        return allowances[owner][spender];\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal {\n        // Make sure the sender has enough tokens.\n        bool canTransfer = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (canTransfer){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n            _moveDelegates(delegates[from], delegates[to], amount);\n        }\n    \n       \n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}",
            "partition": " contract Comp{\n mapping(address => uint64) internal balances;\nmapping(address => uint32) public numCheckpoints;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => mapping(address => uint64)) internal allowances;\nmapping(address => address) public delegates;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction transferFrom(address from, address to, uint64 amount) public returns (bool) {\n        address spender = msg.sender;\n        transferFrom_priv(spender, from, to, amount);\n        return true;\n    }\n\nfunction transferFrom_priv(address spender, address from, address to, uint64 amount) public returns (bool) {\n        _updateAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n    }\n\nfunction _updateAllowance(address owner, address spender, uint64 amount) internal {\n        uint64 currentAllowance = _allowance(owner, spender);\n        bool canApprove = amount <= currentAllowance;\n        if (canApprove) {\n            _approve(owner, spender, currentAllowance - amount);\n        }else{\n            _approve(owner, spender, 0);\n        }\n    }\n\nfunction _allowance(address owner, address spender) internal view returns (uint64) {\n        return allowances[owner][spender];\n    }\n\nfunction _approve(address owner, address spender, uint64 amount) internal {\n        emit Approval(owner, spender, amount);\n        allowances[owner][spender] = amount;\n    }\n\nfunction _transfer(address from, address to, uint64 amount) internal {\n        // Make sure the sender has enough tokens.\n        bool canTransfer = amount <= balances[from];\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        if (canTransfer){\n            balances[to] = balances[to] + amount;\n            balances[from] = balances[from] - amount;\n            emit Transfer(from, to, amount); // Comp.sol (TFHE) has a bug, fake Transfer event will be emitted.\n            _moveDelegates(delegates[from], delegates[to], amount);\n        }\n    \n       \n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}"
        },
        {
            "target_contract_name": "Comp",
            "target_func_name": "delegate",
            "original": " contract Comp{\n mapping(address => address) public delegates;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint64) internal balances;\nmapping(address => uint32) public numCheckpoints;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\nfunction _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint64 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}",
            "partition": " contract Comp{\n mapping(address => address) public delegates;\nmapping(address => uint32) public numCheckpoints;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint64) internal balances;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\nfunction _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _delegate_priv(currentDelegate, delegatee);\n    }\n\nfunction _delegate_priv(address currentDelegate, address delegatee) internal {\n        uint64 delegatorBalance = balances[delegatee];\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}"
        },
        {
            "target_contract_name": "Comp",
            "target_func_name": "delegateBySig",
            "original": " contract Comp{\n mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint32) public numCheckpoints;\nbytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\nmapping(address => uint) public nonces;\nmapping(address => uint64) internal balances;\nmapping(address => address) public delegates;\nbytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\nstring public constant name = \"Compound\";\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"Comp::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\nfunction getChainId() internal view returns (uint) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\nfunction _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint64 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}",
            "partition": " contract Comp{\n bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\nmapping(address => uint) public nonces;\nmapping(address => uint64) internal balances;\nmapping(address => uint32) public numCheckpoints;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => address) public delegates;\nbytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\nstring public constant name = \"Compound\";\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"Comp::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\nfunction getChainId() internal view returns (uint) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\nfunction _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _delegate_priv(currentDelegate, delegatee);\n    }\n\nfunction _delegate_priv(address currentDelegate, address delegatee) internal {\n        uint64 delegatorBalance = balances[delegatee];\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\nfunction _moveDelegates(address srcRep, address dstRep, uint64 amount) internal {\n        if (srcRep != dstRep) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint64 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes :0;\n                uint64 srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint64 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint64 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\nfunction _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint64 oldVotes, uint64 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\nfunction safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2 ** 32, errorMessage);\n        return uint32(n);\n    }}"
        },
        {
            "target_contract_name": "Comp",
            "target_func_name": "getCurrentVotes",
            "original": " contract Comp{\n mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\naddress public allowedContract;\nmapping(address => uint32) public numCheckpoints;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction getCurrentVotes(address account) external onlyAllowedContract returns (uint64) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\nmodifier onlyAllowedContract() {\n        require(msg.sender == allowedContract);\n        _;\n    }}",
            "partition": " contract Comp{\n mapping(address => uint32) public numCheckpoints;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\naddress public allowedContract;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction getCurrentVotes(address account) external onlyAllowedContract returns (uint64) {\n        uint64 points = getCurrentVotes_priv(account);\n        return getCurrentVotes_callback(points);\n    }\n\nfunction getCurrentVotes_priv(address account) internal returns (uint64) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\nfunction getCurrentVotes_callback(uint64 points) internal returns (uint64) {\n        return points;\n    }\n\nmodifier onlyAllowedContract() {\n        require(msg.sender == allowedContract);\n        _;\n    }}"
        },
        {
            "target_contract_name": "Comp",
            "target_func_name": "getPriorVotes",
            "original": " contract Comp{\n mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\naddress public allowedContract;\nmapping(address => uint32) public numCheckpoints;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction getPriorVotes(address account, uint blockNumber) public onlyAllowedContract returns (uint64) {\n        require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\nmodifier onlyAllowedContract() {\n        require(msg.sender == allowedContract);\n        _;\n    }}",
            "partition": " contract Comp{\n mapping(address => uint32) public numCheckpoints;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\naddress public allowedContract;\nstruct Checkpoint {\n        uint32 fromBlock;\n        uint64 votes;\n    }\nevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\nevent DelegateVotesChanged(address indexed delegate, uint64 previousBalance, uint64 newBalance);\nevent Transfer(address indexed from, address indexed to, uint64 amount);\nevent Approval(address indexed owner, address indexed spender, uint64 amount);\n\nfunction getPriorVotes(address account, uint blockNumber) public onlyAllowedContract returns (uint64) {\n        require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n        uint64 points = getPriorVotes_priv(nCheckpoints, account, blockNumber);\n        \n        return getPriorVotes_callback(points);\n    }\n\nmodifier onlyAllowedContract() {\n        require(msg.sender == allowedContract);\n        _;\n    }\n\nfunction getPriorVotes_callback(uint64 points) internal returns (uint64) {\n        return points;\n    }\n\nfunction getPriorVotes_priv(uint32 nCheckpoints, address account, uint blockNumber) internal returns (uint64) {\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }}"
        }
    ],
    "Leaderboard": [
        {
            "target_contract_name": "Leaderboard",
            "target_func_name": "addPlayer",
            "original": " contract Leaderboard{\n mapping(address => Player) public players;\nuint32 private highestScore = 0;\nstruct Player {\n        address user;\n        uint32 score;\n    }\n\n\nfunction addPlayer(address _user, uint32 encryptedScore) public {\n        uint32 score = encryptedScore;\n        bool isAbove = highestScore <= score;\n        if (isAbove){\n            highestScore = score;\n        }\n        \n        // add player to leaderboard\n        players[_user] = Player(_user, score);\n\n    }}",
            "partition": " contract Leaderboard{\n uint32 private highestScore = 0;\nmapping(address => Player) public players;\nstruct Player {\n        address user;\n        uint32 score;\n    }\n\n\nfunction addPlayer(address _user, uint32 encryptedScore) public {\n        addPlayer_priv(_user, encryptedScore);\n    }\n\nfunction addPlayer_priv(address _user, uint32 encryptedScore) internal {\n        uint32 score = encryptedScore;\n        bool isAbove = highestScore <= score;\n        if (isAbove){\n            highestScore = score;\n        }\n        \n        // add player to leaderboard\n        players[_user] = Player(_user, score);\n    }}"
        },
        {
            "target_contract_name": "Leaderboard",
            "target_func_name": "getPlayerScore",
            "original": " contract Leaderboard{\n mapping(address => Player) public players;\nstruct Player {\n        address user;\n        uint32 score;\n    }\n\n\nfunction getPlayerScore(address _user) public view returns (uint32) {\n        require(msg.sender == _user, \"Player score not registered\");\n        return players[_user].score;\n    }}",
            "partition": " contract Leaderboard{\n mapping(address => Player) public players;\nstruct Player {\n        address user;\n        uint32 score;\n    }\n\n\nfunction getPlayerScore(address _user) public view returns (uint32) {\n        require(msg.sender == _user, \"Player score not registered\");\n        uint32 _score = getPlayerScore_priv(_user);\n        return getPlayerScore_callback(_score);\n    }\n\nfunction getPlayerScore_priv(address _user) internal view returns (uint32) {\n        return players[_user].score;\n    }\n\nfunction getPlayerScore_callback(uint32 _score) internal pure returns (uint32) {\n        return _score;\n    }}"
        },
        {
            "target_contract_name": "Leaderboard",
            "target_func_name": "getScoreRelativeToHighestScore",
            "original": " contract Leaderboard{\n mapping(address => Player) public players;\nuint32 private highestScore = 0;\nstruct Player {\n        address user;\n        uint32 score;\n    }\n\n\nfunction getScoreRelativeToHighestScore() public view returns (uint) {\n        uint32 score = players[msg.sender].score;\n        uint32 highest = highestScore;\n        uint32 a = score * 100;\n        uint32 b = highest * 100;\n        uint32 times = a / b;\n        return times;\n    }}",
            "partition": " contract Leaderboard{\n uint32 private highestScore = 0;\nmapping(address => Player) public players;\nstruct Player {\n        address user;\n        uint32 score;\n    }\n\n\nfunction getScoreRelativeToHighestScore() public view returns (uint) {\n       uint times = getScoreRelativeToHighestScore_priv();\n       return getScoreRelativeToHighestScore_callback(times);\n    }\n\nfunction getScoreRelativeToHighestScore_callback(uint _times) internal pure returns (uint) {\n        return _times;\n    }\n\nfunction getScoreRelativeToHighestScore_priv() internal view returns (uint) {\n        uint32 score = players[msg.sender].score;\n        uint32 highest = highestScore;\n        uint32 a = score * 100;\n        uint32 b = highest * 100;\n        uint32 times = a / b;\n        return times;\n    }}"
        }
    ],
    "TokenizedAssets": [
        {
            "target_contract_name": "TokenizedAssets",
            "target_func_name": "tokenizeAsset",
            "original": " contract TokenizedAssets{\n mapping(uint256 => Asset) public assets;\nuint256 public assetCounter;\nstruct Asset {\n        uint32 encryptedData;\n        address owner;\n    }\nevent AssetTokenized(uint256 assetId, uint32 encryptedData, address owner);\nevent AssetTransferred(uint256 assetId, address from, address to);\n\nfunction tokenizeAsset(uint32 encryptedData) public {\n        assetCounter++;\n        assets[assetCounter] = Asset(encryptedData, msg.sender);\n        emit AssetTokenized(assetCounter, encryptedData, msg.sender);\n    }}",
            "partition": " contract TokenizedAssets{\n uint256 public assetCounter;\nmapping(uint256 => Asset) public assets;\nstruct Asset {\n        uint32 encryptedData;\n        address owner;\n    }\nevent AssetTokenized(uint256 assetId, uint32 encryptedData, address owner);\nevent AssetTransferred(uint256 assetId, address from, address to);\n\nfunction tokenizeAsset(uint32 encryptedData) public {\n        assetCounter++;\n        tokenizeAsset_priv(msg.sender, encryptedData);\n    }\n\nfunction tokenizeAsset_priv(address sender, uint32 encryptedData) internal {\n        assets[assetCounter] = Asset(encryptedData, sender);\n        emit AssetTokenized(assetCounter, encryptedData, sender);\n    }}"
        },
        {
            "target_contract_name": "TokenizedAssets",
            "target_func_name": "transferAsset",
            "original": " contract TokenizedAssets{\n mapping(uint256 => Asset) public assets;\nstruct Asset {\n        uint32 encryptedData;\n        address owner;\n    }\nevent AssetTokenized(uint256 assetId, uint32 encryptedData, address owner);\nevent AssetTransferred(uint256 assetId, address from, address to);\n\nfunction transferAsset(uint256 assetId, address newOwner) public {\n        require(assets[assetId].owner == msg.sender, \"Only the owner can transfer the asset.\");\n        address previousOwner = assets[assetId].owner;\n        assets[assetId].owner = newOwner;\n        emit AssetTransferred(assetId, previousOwner, newOwner);\n    }}",
            "partition": " contract TokenizedAssets{\n mapping(uint256 => Asset) public assets;\nstruct Asset {\n        uint32 encryptedData;\n        address owner;\n    }\nevent AssetTokenized(uint256 assetId, uint32 encryptedData, address owner);\nevent AssetTransferred(uint256 assetId, address from, address to);\n\nfunction transferAsset(uint256 assetId, address newOwner) public {\n        transferAsset_priv(msg.sender, assetId, newOwner);\n    }\n\nfunction transferAsset_priv(address sender, uint256 assetId, address newOwner) internal {\n        require(assets[assetId].owner == sender, \"Only the owner can transfer the asset.\");\n        address previousOwner = assets[assetId].owner;\n        assets[assetId].owner = newOwner;\n        emit AssetTransferred(assetId, previousOwner, newOwner);\n    }}"
        },
        {
            "target_contract_name": "TokenizedAssets",
            "target_func_name": "getAsset",
            "original": " contract TokenizedAssets{\n mapping(uint256 => Asset) public assets;\nstruct Asset {\n        uint32 encryptedData;\n        address owner;\n    }\nevent AssetTokenized(uint256 assetId, uint32 encryptedData, address owner);\nevent AssetTransferred(uint256 assetId, address from, address to);\n\nfunction getAsset(uint256 assetId) public view returns (uint32) {\n        require(assets[assetId].owner == msg.sender, \"Only the owner can view the asset.\");\n        return assets[assetId].encryptedData;\n    }}",
            "partition": " contract TokenizedAssets{\n mapping(uint256 => Asset) public assets;\nstruct Asset {\n        uint32 encryptedData;\n        address owner;\n    }\nevent AssetTokenized(uint256 assetId, uint32 encryptedData, address owner);\nevent AssetTransferred(uint256 assetId, address from, address to);\n\nfunction getAsset(uint256 assetId) public view returns (uint32) {\n        uint32 voteData = getAsset_priv(msg.sender, assetId);\n        return getAsset_callback(voteData);\n    }\n\nfunction getAsset_callback(uint32 voteData) internal pure returns (uint32) {\n        return voteData;\n    }\n\nfunction getAsset_priv(address sender, uint256 assetId) internal view returns (uint32) {\n        require(assets[assetId].owner == sender, \"Only the owner can view the asset.\");\n        return assets[assetId].encryptedData;\n    }}"
        }
    ]
}